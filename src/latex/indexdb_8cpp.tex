\hypertarget{indexdb_8cpp}{\section{indexdb.\-cpp File Reference}
\label{indexdb_8cpp}\index{indexdb.\-cpp@{indexdb.\-cpp}}
}
{\ttfamily \#include $<$time.\-h$>$}\\*
{\ttfamily \#include $<$string.\-h$>$}\\*
{\ttfamily \#include $<$errno.\-h$>$}\\*
{\ttfamily \#include \char`\"{}../include/indexdb.\-hpp\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../cmph/cmph.\-h\char`\"{}}\\*
{\ttfamily \#include $<$iomanip$>$}\\*
{\ttfamily \#include $<$sstream$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{E\-N\-T\-R\-Y\-S\-I\-Z\-E}~(2$\ast$sizeof(unsigned int))
\item 
\#define \hyperlink{indexdb_8cpp_ae6d20a71e4f6a058092105f449814f1f}{B\-U\-R\-S\-T}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{indexdb_8cpp_aadd596531a2498e4b29c228ecfe6341a}{insert\-\_\-prefix} (Node\-Element $\ast$trie\-\_\-node, unsigned char $\ast$prefix)
\item 
void \hyperlink{indexdb_8cpp_af3b09b38f41c15440498b0dcfe6239af}{add\-\_\-kmer\-\_\-to\-\_\-table} (kmer\-\_\-origin $\ast$positions\-\_\-tbl, unsigned int seq, unsigned int pos)
\item 
void \hyperlink{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}{freebursttrie} (Node\-Element $\ast$trie\-\_\-node)
\item 
bool \hyperlink{indexdb_8cpp_ae12cbd742f045711033824302716453f}{search\-\_\-burst\-\_\-trie} (Node\-Element $\ast$trie\-\_\-node, unsigned char $\ast$kmer\-\_\-short\-\_\-key, bool \&new\-\_\-position)
\item 
void \hyperlink{indexdb_8cpp_a5c706351c5ed7142c97507cbcb108d0e}{add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie} (Node\-Element $\ast$trie\-\_\-node, unsigned char $\ast$kmer\-\_\-id\-\_\-short\-\_\-\-F\-\_\-ptr, unsigned int id)
\item 
void \hyperlink{indexdb_8cpp_a11ea4ace169605656dcd2ddc58f86de0}{traversetrie} (Node\-Element $\ast$trie\-\_\-node, unsigned int depth)
\item 
void \hyperlink{indexdb_8cpp_a7743cfb5e362845d7a4c2ba708457506}{load\-\_\-index} (kmer $\ast$lookup\-\_\-table, char $\ast$outfile)
\item 
void \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist} ()
\item 
int \hyperlink{indexdb_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\-\_\-nt} \mbox{[}122\mbox{]}
\item 
int \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\-\_\-gv} = -\/1
\item 
int \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\-\_\-gv} = -\/1
\item 
int \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\-\_\-gv} = -\/1
\item 
int \hyperlink{indexdb_8cpp_a07767ad55883c155321a7f7035d24eeb}{numseq\-\_\-gv} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} = 0
\item 
uint64\-\_\-t \hyperlink{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}{mask64} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}{total\-\_\-num\-\_\-trie\-\_\-nodes} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}{size\-\_\-of\-\_\-all\-\_\-buckets} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}{sizeoftrie} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_afee2e2e3b31ffc24935f729aa445c174}{total\-\_\-num\-\_\-buckets} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_aaccb835f1b80ee0a9f2ca20d858bbb35}{high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_a1570d01ca7eadb4a7e458b61cbd9b9dc}{low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket} = 1000
\item 
unsigned int \hyperlink{indexdb_8cpp_a31e084acc6c5e53fc19a7aaacbcb9b63}{longest\-\_\-elem\-\_\-in\-\_\-bucket} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_a1b90ed1106778af012d3402a66de1e45}{shortest\-\_\-elem\-\_\-in\-\_\-bucket} = 1000
\item 
unsigned int \hyperlink{indexdb_8cpp_ab52f265ad9d023c852bf5c424d35670a}{all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_ab5717b1f88f08cc3d1dd58ad50efc222}{all\-\_\-elem\-\_\-in\-\_\-buckets} = 0
\item 
unsigned int \hyperlink{indexdb_8cpp_a0a9cef6c669464bde4a09196192d043f}{avg\-\_\-len} \mbox{[}11\mbox{]} = \{0\}
\item 
unsigned int \hyperlink{indexdb_8cpp_a86be46befd57f331a8f028e2d9571152}{num\-\_\-elem} \mbox{[}100\mbox{]} = \{0\}
\item 
bool \hyperlink{indexdb_8cpp_ab3f078684998b83967d507d0f453f454}{verbose} = false
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{indexdb_8cpp_ae6d20a71e4f6a058092105f449814f1f}{\index{indexdb.\-cpp@{indexdb.\-cpp}!B\-U\-R\-S\-T@{B\-U\-R\-S\-T}}
\index{B\-U\-R\-S\-T@{B\-U\-R\-S\-T}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{B\-U\-R\-S\-T}]{\setlength{\rightskip}{0pt plus 5cm}\#define B\-U\-R\-S\-T}}\label{indexdb_8cpp_ae6d20a71e4f6a058092105f449814f1f}
\hypertarget{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{\index{indexdb.\-cpp@{indexdb.\-cpp}!E\-N\-T\-R\-Y\-S\-I\-Z\-E@{E\-N\-T\-R\-Y\-S\-I\-Z\-E}}
\index{E\-N\-T\-R\-Y\-S\-I\-Z\-E@{E\-N\-T\-R\-Y\-S\-I\-Z\-E}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{E\-N\-T\-R\-Y\-S\-I\-Z\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define E\-N\-T\-R\-Y\-S\-I\-Z\-E~(2$\ast$sizeof(unsigned int))}}\label{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}


\subsection{Function Documentation}
\hypertarget{indexdb_8cpp_a5c706351c5ed7142c97507cbcb108d0e}{\index{indexdb.\-cpp@{indexdb.\-cpp}!add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie@{add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie}}
\index{add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie@{add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie}]{\setlength{\rightskip}{0pt plus 5cm}void add\-\_\-id\-\_\-to\-\_\-burst\-\_\-trie (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-node, }
\item[{unsigned char $\ast$}]{kmer\-\_\-id\-\_\-short\-\_\-\-F\-\_\-ptr, }
\item[{unsigned int}]{id}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a5c706351c5ed7142c97507cbcb108d0e}

\begin{DoxyCode}
436 \{
437     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} depth = 0;
438 
439     \textcolor{comment}{/* find a terminal trie node */}
440     NodeElement *node\_elem = (NodeElement*)(trie\_node + *kmer\_id\_short\_F\_ptr++);
441     depth++;
442 
443     \textcolor{keywordflow}{while} ( node\_elem->flag == 1 )
444     \{
445         trie\_node = node\_elem->whichnode.trie;
446         node\_elem = (NodeElement*)(trie\_node + *kmer\_id\_short\_F\_ptr++);
447         depth++;
448     \} 
449         
450     \textcolor{comment}{/* encode the remaining part of kmer\_id\_short\_F using 4 nt per byte */}
451     \textcolor{keywordtype}{int} s = \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}+1-depth;
452 
453     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} encode = 0;
454     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < s; i++ )
455     \{
456         encode |= ((\textcolor{keywordtype}{unsigned} int)*kmer\_id\_short\_F\_ptr++)<<(2*i);
457     \}
458 
459     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* start\_bucket = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem->whichnode.bucket;          
460     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* end\_bucket = start\_bucket + node\_elem->size;
461 
462     \textcolor{comment}{/* to mask the last nucleotide of 19-mer */}
463     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} msk = (1<<(2*(s-1)))-1;
464 
465     \textcolor{comment}{/* compare the 1 byte representation of kmer\_id\_short\_F with all}
466 \textcolor{comment}{            elements in the bucket */}
467     \textcolor{keywordflow}{while} ( start\_bucket != end\_bucket )
468     \{
469         \textcolor{comment}{/* set the id */}
470         \textcolor{keywordflow}{if} ( (encode&msk) == (*((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket)&msk ) )
471         \{
472             *((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)(start\_bucket+\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}))) = id;
473             
474             \textcolor{comment}{//return ;}
475         \}
476         start\_bucket+=\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
477     \}
478     
479     return ;
480 \}\textcolor{comment}{//~add\_id\_to\_burst\_trie()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_af3b09b38f41c15440498b0dcfe6239af}{\index{indexdb.\-cpp@{indexdb.\-cpp}!add\-\_\-kmer\-\_\-to\-\_\-table@{add\-\_\-kmer\-\_\-to\-\_\-table}}
\index{add\-\_\-kmer\-\_\-to\-\_\-table@{add\-\_\-kmer\-\_\-to\-\_\-table}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{add\-\_\-kmer\-\_\-to\-\_\-table}]{\setlength{\rightskip}{0pt plus 5cm}void add\-\_\-kmer\-\_\-to\-\_\-table (
\begin{DoxyParamCaption}
\item[{kmer\-\_\-origin $\ast$}]{positions\-\_\-tbl, }
\item[{unsigned int}]{seq, }
\item[{unsigned int}]{pos}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{indexdb_8cpp_af3b09b38f41c15440498b0dcfe6239af}

\begin{DoxyCode}
284 \{
285     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size = positions\_tbl->size;
286 
287     \textcolor{comment}{/* create an entry for the new unique k-mer occurrence */}
288     \textcolor{keywordflow}{if} ( size == 0 )
289     \{
290         positions\_tbl->arr = (seq\_pos*)malloc(\textcolor{keyword}{sizeof}(seq\_pos));
291         memset(positions\_tbl->arr,0,\textcolor{keyword}{sizeof}(seq\_pos));
292     \}
293     \textcolor{comment}{/* add a position for an existing k-mer occurrence */}
294     \textcolor{keywordflow}{else}
295     \{
296         \textcolor{comment}{/* we can store maximum 255 occurrences of k-mers */}
297         \textcolor{keywordflow}{if} ( size == 255 )
298             return ;
299 
300         seq\_pos* src = positions\_tbl->arr;
301         positions\_tbl->arr = (seq\_pos*)malloc((size+1)*\textcolor{keyword}{sizeof}(seq\_pos));
302         memset(positions\_tbl->arr,0,(size+1)*\textcolor{keyword}{sizeof}(seq\_pos));
303         memcpy(positions\_tbl->arr, src, size*\textcolor{keyword}{sizeof}(seq\_pos));
304 
305         free(src);
306     \}
307 
308     positions\_tbl->arr[size].seq = seq;
309     positions\_tbl->arr[size].pos = pos;
310     positions\_tbl->size++;
311 
312 \}\textcolor{comment}{//~add\_kmer\_to\_table}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}{\index{indexdb.\-cpp@{indexdb.\-cpp}!freebursttrie@{freebursttrie}}
\index{freebursttrie@{freebursttrie}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{freebursttrie}]{\setlength{\rightskip}{0pt plus 5cm}void freebursttrie (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-node}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}

\begin{DoxyCode}
324 \{
325     \textcolor{comment}{/* traverse through the node elements in a trie node */}
326     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
327     \{
328         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} value = trie\_node->flag;
329 
330         \textcolor{comment}{/* the node element holds a pointer to another trie node */}
331         \textcolor{keywordflow}{if} ( value == 1 )
332         \{ 
333             \hyperlink{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}{freebursttrie} ( (NodeElement*)(trie\_node->whichnode.trie) );
334             free(trie\_node++->whichnode.trie);
335         \}
336 
337         \textcolor{comment}{/* the node element points to a bucket */}
338         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( value == 2 )
339         \{
340             free( trie\_node++->whichnode.bucket );
341         \}
342 
343         \textcolor{comment}{/* the node element is empty, go to next node element */}
344         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( value == 0 ) \{    trie\_node++; \}
345 
346     \}\textcolor{comment}{//~trie nodes}
347 
348     \textcolor{keywordflow}{return};
349 
350 \}\textcolor{comment}{//~freebursttrie()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_aadd596531a2498e4b29c228ecfe6341a}{\index{indexdb.\-cpp@{indexdb.\-cpp}!insert\-\_\-prefix@{insert\-\_\-prefix}}
\index{insert\-\_\-prefix@{insert\-\_\-prefix}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{insert\-\_\-prefix}]{\setlength{\rightskip}{0pt plus 5cm}void insert\-\_\-prefix (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-node, }
\item[{unsigned char $\ast$}]{prefix}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{indexdb_8cpp_aadd596531a2498e4b29c228ecfe6341a}

\begin{DoxyCode}
117 \{
118     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} depth = 0;
119     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sig = 0;
120 
121     \textcolor{comment}{/* find a terminal trie node */}
122     NodeElement *node\_elem = (NodeElement*)(trie\_node + *prefix++);
123     depth++;
124 
125     \textcolor{keywordflow}{while} ( node\_elem->flag == 1 )
126     \{
127         trie\_node = node\_elem->whichnode.trie;
128         node\_elem = (NodeElement*)(trie\_node + *prefix++);
129         depth++;
130     \} 
131 
132     \textcolor{comment}{/* length of entry to add to bucket */}
133     \textcolor{keywordtype}{int} s = \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}+1-depth;
134 
135     \textcolor{comment}{/* a bucket does not exist, create one */}
136     \textcolor{keywordflow}{if} ( node\_elem->flag == 0 )
137     \{
138         \textcolor{comment}{/* set the baseptr to the beginning of the new bucket */}
139         node\_elem->whichnode.bucket = (\textcolor{keywordtype}{void}*)malloc(\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
140         \textcolor{keywordflow}{if} ( node\_elem->whichnode.bucket == NULL )
141         \{
142             cerr << \textcolor{stringliteral}{"  ERROR: could not allocate memory for bucket (insert\_prefix() in indexdb.cpp)\(\backslash\)n"};
143             exit(EXIT\_FAILURE);
144         \}
145         \textcolor{comment}{/* initialize bucket memory to 0 */}
146         memset(node\_elem->whichnode.bucket, 0, \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
147         \textcolor{comment}{/* set flag to signify the existence of a bucket */}
148         node\_elem->flag = 2;
149         node\_elem->size = 0;
150     \} 
151 
152     \textcolor{comment}{/* a bucket does exist, allocate memory for 1 more entry */}
153     \textcolor{keywordflow}{else}
154     \{
155         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} node\_elem\_size = node\_elem->size;
156         \textcolor{keywordtype}{void}* src = node\_elem->whichnode.bucket;
157 
158         node\_elem->whichnode.bucket = (\textcolor{keywordtype}{void}*)malloc(node\_elem\_size+\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
159         \textcolor{keywordflow}{if} ( node\_elem->whichnode.bucket == NULL )
160         \{
161             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for bucket resize (insert\_prefix() in
       indexdb.cpp): %s\(\backslash\)n"},strerror(errno));
162             exit(EXIT\_FAILURE);
163         \}
164 
165         memset(node\_elem->whichnode.bucket, 0, node\_elem\_size+\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
166         memcpy((\textcolor{keywordtype}{void}*)node\_elem->whichnode.bucket, (\textcolor{keywordtype}{void}*)src, node\_elem\_size);
167 
168         free(src);
169     \}
170 
171     \textcolor{comment}{/* add tail to bucket */}
172     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* entry = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem->whichnode.bucket + node\_elem->size);
173 
174     \textcolor{comment}{/* add the tail to the bucket */}
175     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} encode = 0;
176     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < s; i++ )
177     \{
178         encode |= ((\textcolor{keywordtype}{unsigned} int)*prefix++)<<(2*i);
179     \}
180 
181     *entry++ = encode;
182 
183     \textcolor{comment}{/* add the signature of the prefix following the tail */}
184     *entry = sig;
185 
186     \textcolor{comment}{/* record the new size of bucket */}
187     (node\_elem->size)+=\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
188     
189 \textcolor{preprocessor}{    #define BURST}
190 \textcolor{preprocessor}{}\textcolor{preprocessor}{    #ifdef BURST}
191 \textcolor{preprocessor}{}    \textcolor{comment}{/* (-3 = -2*k-1) smallest bucket must have at least 3-character strings */}
192     \textcolor{keywordflow}{if} ( depth < (\hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}-\hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-3) )
193     \{
194         \textcolor{comment}{/* burst if next string will exceed bucket limit */}
195         \textcolor{keywordflow}{if} ( node\_elem->size > THRESHOLD )
196         \{
197             \textcolor{comment}{/* create a new trie node */}
198             NodeElement* child\_node = (NodeElement*)malloc(4*\textcolor{keyword}{sizeof}(NodeElement));
199             \textcolor{keywordflow}{if} ( child\_node == NULL )
200             \{
201                 cout << \textcolor{stringliteral}{"  ERROR: could not allocate memory for child\_node (insert\_prefix())\(\backslash\)n"};
202                 exit(EXIT\_FAILURE);
203             \}
204             memset(child\_node, 0, 4*\textcolor{keyword}{sizeof}(NodeElement));
205 
206             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* start\_bucket\_to\_burst = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem->whichnode.bucket;         
207             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* end\_bucket\_to\_burst = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem->whichnode.bucket + node\_elem->
      size;
208 
209             \textcolor{comment}{/* read every entry in the bucket to burst */}
210             \textcolor{keywordflow}{while} ( start\_bucket\_to\_burst != end\_bucket\_to\_burst )
211             \{
212                     NodeElement* node\_elem\_child = (NodeElement*)(child\_node + ((*start\_bucket\_to\_burst)&3)
      );
213 
214                     \textcolor{comment}{/* create a new child bucket */}
215                     \textcolor{keywordflow}{if} ( node\_elem\_child->flag == 0 )
216                     \{
217                         node\_elem\_child->whichnode.bucket = (\textcolor{keywordtype}{void}*)malloc(
      \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
218                         \textcolor{keywordflow}{if} (node\_elem\_child->whichnode.bucket == NULL)  
219                         \{
220                             cout << \textcolor{stringliteral}{"  ERROR: could not allocate memory for child bucket (insert\_prefix())
      \(\backslash\)n"};
221                             exit(EXIT\_FAILURE);
222                         \}
223                         memset(node\_elem\_child->whichnode.bucket, 0, \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
224                         node\_elem\_child->flag = 2;
225                         node\_elem\_child->size = 0;
226                     \}
227                     \textcolor{comment}{/* flag == 2, resize the existing bucket to add an extra element */}
228                     \textcolor{keywordflow}{else}
229                     \{
230                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} child\_bucket\_size = node\_elem\_child->size;
231                         \textcolor{keywordtype}{void}* src = node\_elem\_child->whichnode.bucket;
232                         node\_elem\_child->whichnode.bucket = (\textcolor{keywordtype}{void}*)malloc(child\_bucket\_size+
      \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
233                         \textcolor{keywordflow}{if} ( node\_elem\_child->whichnode.bucket == NULL )
234                         \{
235                             cout << \textcolor{stringliteral}{"  ERROR: could not allocate memory for child bucket resize
       (insert\_prefix() in indexdb.cpp)\(\backslash\)n"};
236                             exit(EXIT\_FAILURE);
237                         \}   
238                         memset(node\_elem\_child->whichnode.bucket, 0, child\_bucket\_size+
      \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
239                         memcpy(node\_elem\_child->whichnode.bucket, src, child\_bucket\_size);
240                         free(src);
241                     \}
242     
243                     \textcolor{comment}{/* shift all bits in an entry to make up for the removed nucleotide */}
244                     *((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket\_to\_burst)>>=2;
245 
246                     \textcolor{comment}{/* add an element to the bucket */}
247                     memcpy( (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem\_child->whichnode.bucket + node\_elem\_child->size, 
      start\_bucket\_to\_burst, \hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE});
248     
249                     (node\_elem\_child->size)+=\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
250 
251                     \textcolor{comment}{/* each entry is 2 unsigned ints */}
252                     start\_bucket\_to\_burst+=\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
253             \}
254             
255             \textcolor{comment}{/* reset the flag and size of the parent node */}
256             free(node\_elem->whichnode.bucket);
257             node\_elem->whichnode.trie = child\_node;
258             node\_elem->flag = 1; \textcolor{comment}{/* now points to the child node */}
259             node\_elem->size = 0; \textcolor{comment}{/* size of bucket = 0 */}
260 
261 
262         \}\textcolor{comment}{//~burst bucket}
263     \}\textcolor{comment}{//~depth < pread\_gv-2k-1}
264 \textcolor{preprocessor}{    #endif}
265 \textcolor{preprocessor}{}
266     return ;
267 \}\textcolor{comment}{//~insert\_prefix()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a7743cfb5e362845d7a4c2ba708457506}{\index{indexdb.\-cpp@{indexdb.\-cpp}!load\-\_\-index@{load\-\_\-index}}
\index{load\-\_\-index@{load\-\_\-index}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{load\-\_\-index}]{\setlength{\rightskip}{0pt plus 5cm}void load\-\_\-index (
\begin{DoxyParamCaption}
\item[{kmer $\ast$}]{lookup\-\_\-table, }
\item[{char $\ast$}]{outfile}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a7743cfb5e362845d7a4c2ba708457506}

\begin{DoxyCode}
571 \{
572     \textcolor{comment}{/* output the mini-burst tries */}
573     ofstream btrie ( outfile, ofstream::binary );
574 
575     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sizeoftries[2] = \{0\};
576 
577     \textcolor{comment}{/* loop through all 9-mers */}
578     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}); i++ )
579     \{
580         NodeElement* trienode = NULL;
581 
582         \textcolor{comment}{/* 1. output size for the two mini-burst tries for each 9-mer */}
583         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < 2; j++ )
584         \{
585             \hyperlink{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}{total\_num\_trie\_nodes} = 0;
586             \hyperlink{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}{size\_of\_all\_buckets} = 0;
587             \textcolor{keywordflow}{if} ( j == 0 )
588                 trienode = lookup\_table[i].trie\_F;
589             \textcolor{keywordflow}{else}    
590                 trienode = lookup\_table[i].trie\_R;
591 
592             \textcolor{keywordflow}{if} ( trienode != NULL )
593                 \hyperlink{indexdb_8cpp_a11ea4ace169605656dcd2ddc58f86de0}{traversetrie} ( trienode++, 0 );
594             \hyperlink{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}{sizeoftrie} = \hyperlink{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}{total\_num\_trie\_nodes}*\textcolor{keyword}{sizeof}(NodeElement)*4 + 
      \hyperlink{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}{size\_of\_all\_buckets}*\textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char});
595 
596             sizeoftries[j] = \hyperlink{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}{sizeoftrie};
597 
598             btrie.write(reinterpret\_cast<const char*>(&\hyperlink{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}{sizeoftrie}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
599         \}
600 
601         \textcolor{comment}{/* 2. output both mini-burst tries into binary file */}
602         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < 2; j++ )
603         \{
604             \textcolor{comment}{/* the mini-burst trie exists, load into memory */}              
605             \textcolor{keywordflow}{if} ( sizeoftries[j] != 0 ) 
606             \{
607                 \textcolor{keywordflow}{if} ( j == 0 )
608                     trienode = lookup\_table[i].trie\_F;
609                 \textcolor{keywordflow}{else}    
610                     trienode = lookup\_table[i].trie\_R;
611 
612                 \textcolor{comment}{/* queue of node elements for breadth-first traversal */}
613                 deque<NodeElement*> nodes;
614 
615                 \textcolor{comment}{/* load first set of NodeElements into the queue & write to file */}
616                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
617                 \{
618                     nodes.push\_back( trienode );
619                     btrie.write(reinterpret\_cast<const char*>(&(trienode->flag)), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));
620                     trienode++;
621                 \}
622 
623                 \textcolor{keywordtype}{int} depth = 0;
624                 \textcolor{keywordtype}{int} poplimit = 4;
625                 \textcolor{keywordtype}{int} numpops = 0;
626                 \textcolor{keywordtype}{int} topop = 0;
627 
628                 \textcolor{keywordflow}{while} ( !nodes.empty() )
629                 \{
630                     \textcolor{comment}{/* increment depth of burst trie */}
631                     \textcolor{keywordflow}{if} ( numpops == poplimit )
632                     \{
633                         depth++;
634                         poplimit = topop;
635                         numpops = 0;
636                         topop = 0;
637                     \}
638 
639                     trienode = nodes.front();
640     
641                     \textcolor{keywordflow}{switch} ( trienode->flag )
642                     \{
643                         \textcolor{comment}{/* empty node */}
644                         \textcolor{keywordflow}{case} 0:
645                         \{
646                             ;
647                         \}
648                         \textcolor{keywordflow}{break};
649                         \textcolor{comment}{/* trie node, add child trie node to queue */}
650                         \textcolor{keywordflow}{case} 1:
651                         \{
652                             NodeElement *child = trienode->whichnode.trie;
653                             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
654                             \{
655                                 nodes.push\_back( child );
656                                 btrie.write(reinterpret\_cast<const char*>(&(child->flag)), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{
      char}));
657                                 child++;
658                             \}
659                             topop+=4;
660                         \}
661                         \textcolor{keywordflow}{break};
662                         \textcolor{comment}{/* bucket node, add bucket to output file */}
663                         \textcolor{keywordflow}{case} 2:
664                         \{
665                             \textcolor{keywordtype}{char}* bucket = (\textcolor{keywordtype}{char}*)(trienode->whichnode.bucket);
666 
667                             \textcolor{comment}{/* bucket information */}
668                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sizeofbucket = trienode->size;
669 
670                             btrie.write(reinterpret\_cast<const char*>(&sizeofbucket), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}))
      ;
671             
672                             \textcolor{comment}{/* bucket content */}
673                             \textcolor{keywordtype}{char}* start = (\textcolor{keywordtype}{char}*)bucket;
674 
675                             btrie.write(reinterpret\_cast<const char*>(start), sizeofbucket);
676                         \}
677                         \textcolor{keywordflow}{break};
678                         \textcolor{comment}{/* ? */}
679                         \textcolor{keywordflow}{default}:
680                         \{
681                             fprintf(stderr, \textcolor{stringliteral}{"  ERROR: flag is not set (load\_index)\(\backslash\)n"}); 
682                             exit(EXIT\_FAILURE);
683                         \}
684                         \textcolor{keywordflow}{break};
685                     \}
686 
687                     nodes.pop\_front();  
688                     numpops++;
689 
690                 \}\textcolor{comment}{//~while the queue is not empty}
691             \}\textcolor{comment}{//~if mini-burst trie exists}
692         \}\textcolor{comment}{//~for each mini-burst trie in the 9-mer}
693     \}\textcolor{comment}{//~for each 9-mer}
694 
695     btrie.close();
696 
697 \}\textcolor{comment}{//~load\_index()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{\index{indexdb.\-cpp@{indexdb.\-cpp}!main@{main}}
\index{main@{main}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int main (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}

\begin{DoxyCode}
736 \{
737     \textcolor{keywordtype}{int} narg = 1;
738     \textcolor{comment}{/* file name of the database */}
739     \textcolor{keywordtype}{char} * dbsfile = NULL;
740     \textcolor{comment}{/* time */}
741     \textcolor{keywordtype}{double}  s = 0.0;
742     \textcolor{keywordtype}{double}  f = 0.0; 
743     \textcolor{comment}{/* memory of index */}
744     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} mem = 0;
745     \textcolor{keywordtype}{bool} mem\_is\_set = \textcolor{keyword}{false};
746   \textcolor{keywordtype}{bool} fast\_set = \textcolor{keyword}{false};
747     \textcolor{keywordtype}{bool} sensitive\_set = \textcolor{keyword}{false};
748     vector< pair<string,unsigned int> > sam\_sq\_header;
749 
750     timeval \hyperlink{main_8cpp_a2d39cd4e5b05734e0540770673399a64}{t};
751 
752 
753     \textcolor{comment}{/* character array to hold an unsigned long long integer for CMPH */}
754     \textcolor{keywordtype}{char} a[38] = \{0\};
755 
756     \textcolor{keywordflow}{while} ( narg < argc )
757     \{
758         \textcolor{keywordflow}{switch}( argv[narg][1] )
759         \{
760             \textcolor{comment}{/*  */}
761             \textcolor{keywordflow}{case} \textcolor{charliteral}{'-'}: 
762             \{
763                 \textcolor{keywordtype}{char}* myoption = argv[narg];
764                 \textcolor{comment}{/* skip the '--' */}
765                 myoption+=2;
766 
767                 \textcolor{comment}{/* path to genome file */}
768                 \textcolor{keywordflow}{if} ( strcmp ( myoption, \textcolor{stringliteral}{"ref"}) == 0 )
769                 \{
770                     \textcolor{keywordflow}{if} ( argv[narg+1] == NULL )
771                     \{
772                         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: --ref must be followed by a file name (incl. path).\(\backslash\)n\(\backslash\)n"}
      );
773                         exit(EXIT\_FAILURE);
774                     \}
775                     dbsfile = argv[narg+1];
776                     narg+=2;
777                 \}
778                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( strcmp ( myoption, \textcolor{stringliteral}{"fast"}) == 0 )
779                 \{   
780                     \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} > 0 )
781                     \{
782                         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: option -L INT cannot be used with --fast or --sensitive
       (these options set default values for L).\(\backslash\)n\(\backslash\)n"});
783                         exit(EXIT\_FAILURE);
784                     \}
785                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !fast\_set )
786                     \{
787                         \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} = 24;
788                     \}
789                     \textcolor{keywordflow}{else}
790                     \{   
791                             fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: --fast has already been set once.\(\backslash\)n\(\backslash\)n"}); 
792                             exit(EXIT\_FAILURE);
793                     \}
794                     fast\_set = \textcolor{keyword}{true};
795                     narg++;
796                 \}
797                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( strcmp ( myoption, \textcolor{stringliteral}{"sensitive"}) == 0 )
798                 \{
799                     \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} > 0 )
800                     \{
801                         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: option -L INT cannot be used with --sensitive or --fast
       (these options set default values for L).\(\backslash\)n\(\backslash\)n"});
802                         exit(EXIT\_FAILURE);
803                     \}
804                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( !sensitive\_set )
805                         \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} = 18;
806                     \textcolor{keywordflow}{else}
807                     \{   
808                             fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: --sensitive has already been set once.\(\backslash\)n\(\backslash\)n"});    
809                             exit(EXIT\_FAILURE);
810                     \}
811                     sensitive\_set = \textcolor{keyword}{true};
812                     narg++;
813                 \}
814                 \textcolor{keywordflow}{else}
815                 \{
816                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: unknown option --%s.\(\backslash\)n\(\backslash\)n"},myoption);
817                     \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist}();   
818                     exit(EXIT\_FAILURE);
819                 \}
820             \}
821             \textcolor{keywordflow}{break};
822 
823             \textcolor{keywordflow}{case} \textcolor{charliteral}{'L'}: 
824             \{
825                 \textcolor{keywordflow}{if} ( fast\_set || sensitive\_set )
826                 \{
827                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: -L INT cannot not be set when --fast or --sensitive options are used
       (these options set default values for L).\(\backslash\)n\(\backslash\)n"});
828                     exit(EXIT\_FAILURE);
829                 \}
830 
831                 \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} > 0 )
832                 \{   
833                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: option -L can only be set once.\(\backslash\)n\(\backslash\)n"});
834                     exit(EXIT\_FAILURE);
835                 \}
836 
837                 \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} = atoi(argv[narg+1]); 
838 
839                 \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} <= 0 )
840                 \{
841                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: -L must be a positive integer (10, 12, 14, .. , 20).\(\backslash\)n\(\backslash\)n"});
842                     exit(EXIT\_FAILURE);
843                 \}
844                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}%2 == 1 )
845                 \{
846                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: -L must be an even integer (10, 12, 14, .. , 20).\(\backslash\)n\(\backslash\)n"});
847                     exit(EXIT\_FAILURE);
848                 \}
849                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} < 8) || (\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} > 26) )
850                 \{
851                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: -L must be between 8 and 26, inclusive.\(\backslash\)n\(\backslash\)n"});
852                     exit(EXIT\_FAILURE);
853                 \}
854                 \textcolor{keywordflow}{else}
855                 \{
856                     \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv} = \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}+1;
857                     \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv} = \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}/2;
858                     narg+=2;
859                 \}
860             \}                  
861             \textcolor{keywordflow}{break};
862 
863             \textcolor{keywordflow}{case} \textcolor{charliteral}{'m'}: 
864             \{
865                 \textcolor{comment}{/* set memory for index */}
866                 \textcolor{keywordflow}{if} ( !mem\_is\_set )
867                 \{
868                     mem = atof(argv[narg+1]);  
869                     \textcolor{keywordflow}{if} ( mem < 1000 ) 
870                     \{
871                         printf(\textcolor{stringliteral}{"\(\backslash\)n   ERROR: -m %lld is too little memory to construct an index. Make sure
       -m INT is in bytes.\(\backslash\)n"},mem);  
872                         exit(EXIT\_FAILURE);
873                     \}  
874                     narg+=2;
875                     mem\_is\_set = \textcolor{keyword}{true};
876                 \}
877                 \textcolor{keywordflow}{else}
878                 \{
879                     printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: option -m can only be set once,\(\backslash\)n\(\backslash\)n"});
880                     \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist}();
881                 \}
882             \}                  
883             \textcolor{keywordflow}{break};
884 
885             \textcolor{keywordflow}{case} \textcolor{charliteral}{'v'}: 
886             \{
887                 \textcolor{comment}{/* verbose  */}
888                 \textcolor{keywordflow}{if} ( !\hyperlink{indexdb_8cpp_ab3f078684998b83967d507d0f453f454}{verbose} )
889                 \{
890                     \hyperlink{indexdb_8cpp_ab3f078684998b83967d507d0f453f454}{verbose} = \textcolor{keyword}{true};
891                     narg++;
892                 \}
893             \}                  
894             \textcolor{keywordflow}{break};
895 
896             \textcolor{keywordflow}{case} \textcolor{charliteral}{'h'}: 
897             \{   
898                 \textcolor{comment}{/* help */}
899                 \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist}();
900             \}
901             \textcolor{keywordflow}{break};
902 
903             \textcolor{keywordflow}{default} : 
904             \{
905                 printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: '%c' is not one of the options\(\backslash\)n\(\backslash\)n"}, argv[narg][1]);
906                 \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist}();
907             \} 
908         \}\textcolor{comment}{//~switch}
909     \}\textcolor{comment}{//~while ( narg < argc )}
910 
911 
912     \textcolor{comment}{/* check that the database file has been provided */}
913     \textcolor{keywordflow}{if} ( dbsfile == NULL )
914     \{
915         printf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: a genome or database file (--ref file.\{fasta\}) is mandatory input\(\backslash\)n\(\backslash\)n"});
916         \hyperlink{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{printlist}();
917     \} 
918 
919     \textcolor{comment}{/* set the default value for seed length */}
920     \textcolor{keywordflow}{if} ( \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} < 0 ) 
921         \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} = 18;
922 
923     \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv} = \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}+1;
924     \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv} = \hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}/2;
925 
926     \textcolor{comment}{/* default memory for building index 3GB */}
927     \textcolor{keywordflow}{if} ( mem == 0 )
928         mem = 3221225472;
929 
930     \hyperlink{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} = (1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv})-1;
931     \hyperlink{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}{mask64} = (2ULL<<((\hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}*2)-1))-1;
932 
933 
934     \textcolor{keywordtype}{char} filen[255];
935     \textcolor{keywordtype}{char} *ptr = strrchr( dbsfile, \textcolor{charliteral}{'/'});
936     \textcolor{keywordflow}{if} ( ptr != NULL )
937         strcpy( filen, ptr+1 );
938     \textcolor{keywordflow}{else}
939         strcpy ( filen, dbsfile );
940 
941     ptr = strrchr( filen, \textcolor{charliteral}{'.'});
942     \textcolor{keywordflow}{if} ( ptr != 0 ) *ptr = 0;
943     \textcolor{keywordtype}{string} root = filen;
944 
945 
946     \textcolor{comment}{/* environment variable for SortMeDNA directory */}
947     \textcolor{keywordtype}{char} * pPath;
948     pPath = getenv (\textcolor{stringliteral}{"SORTMEDNADIR"});
949     \textcolor{keywordflow}{if} ( pPath == NULL )
950     \{
951         fprintf(stderr, \textcolor{stringliteral}{"Cannot find the SORTMEDNADIR environment variable.\(\backslash\)n"});
952         exit(EXIT\_FAILURE);
953     \}
954 
955 
956     \textcolor{keywordtype}{string} path = pPath;
957 
958     \textcolor{comment}{/* reference sequences input file */}
959     \textcolor{keywordtype}{string} fname = dbsfile;
960 
961     FILE *fp = fopen(fname.c\_str(),\textcolor{stringliteral}{"r"});
962     \textcolor{keywordflow}{if} ( fp == NULL )
963     \{
964         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not open file %s\(\backslash\)n"},fname.c\_str());
965         exit(EXIT\_FAILURE);
966     \}
967      
968 
969   \textcolor{comment}{/* STEP 1 *******************************************************************************/}
970     \textcolor{comment}{/* For file part\_0, (a) compute the nucleotide background frequencies;}
971 \textcolor{comment}{                        (b) length of total reference sequences (for Gumbel parameters);}
972 \textcolor{comment}{                      (c) number of total sequences (for SW alignment) */}
973 
974 
975     \textcolor{comment}{/* total number of reference sequences */}
976     \textcolor{keywordtype}{size\_t} strs = 0;
977   \textcolor{comment}{/* length of longest single sequence */}
978     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} maxlen = 0;
979   \textcolor{comment}{/* length of single sequence */}
980     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len = 0;
981     \textcolor{comment}{/* the percentage of each A/C/G/T in the database */}
982     \textcolor{keywordtype}{double} background\_freq[4] = \{0.0,0.0,0.0,0.0\};
983   \textcolor{comment}{/* total length of reference sequences */}
984     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} full\_len = 0;
985     \textcolor{keywordtype}{int} nt = 0;
986 
987     eprintf(\textcolor{stringliteral}{"  Collecting sequence distribution statistics .."});
988 
989     TIME(s);
990     \textcolor{keywordflow}{do}
991     \{
992         nt = fgetc(fp);
993 
994         \textcolor{comment}{/* name of sequence for SAM format @SQ */}
995         \textcolor{keywordtype}{char} read\_header[2000];
996         \textcolor{keywordtype}{char} *pt\_h = read\_header;
997  
998         \textcolor{comment}{/* start of read header */}
999         \textcolor{keywordflow}{if} ( nt == \textcolor{charliteral}{'>'} ) strs+=2;
1000         \textcolor{keywordflow}{else}
1001         \{
1002             cout << \textcolor{stringliteral}{"\(\backslash\)n  ERROR: each read header of the database fasta file must begin with '>';"};
1003             cout << \textcolor{stringliteral}{"\(\backslash\)n  check sequence # "} << strs << \textcolor{stringliteral}{"\(\backslash\)n\(\backslash\)n"};  
1004             exit(EXIT\_FAILURE);
1005         \}
1006 
1007         \textcolor{comment}{/* scan to end of header name */}
1008         \textcolor{keywordtype}{bool} stop = \textcolor{keyword}{false};
1009         \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'\(\backslash\)n'} ) 
1010         \{
1011             nt = fgetc(fp);
1012             \textcolor{keywordflow}{if} (nt != \textcolor{charliteral}{'\(\backslash\)n'} && nt != \textcolor{charliteral}{' '} && nt != \textcolor{charliteral}{'\(\backslash\)t'} && !stop)
1013                 *pt\_h++ = nt;
1014             \textcolor{keywordflow}{else}
1015                 stop = \textcolor{keyword}{true};
1016         \}
1017 
1018         *pt\_h = \textcolor{charliteral}{'\(\backslash\)0'};
1019 
1020         len = 0;
1021 
1022         \textcolor{comment}{/* scan through the sequence, count its length */}
1023         nt = fgetc(fp);
1024         \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'>'} && nt != EOF ) 
1025         \{
1026             \textcolor{comment}{/* skip line feed, carriage return or empty space in the sequence */}
1027             \textcolor{keywordflow}{if} ( nt != \textcolor{charliteral}{'\(\backslash\)n'} && nt != \textcolor{charliteral}{' '} )
1028             \{
1029                 len++;
1030                 \textcolor{keywordflow}{if} ( nt != \textcolor{charliteral}{'N'} )
1031                     background\_freq[(int)\hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[nt]]++;
1032             \}
1033             nt = fgetc(fp);
1034         \} 
1035 
1036         \textcolor{comment}{/* add sequence name and length to sam\_header\_*/}
1037         \textcolor{keywordtype}{string} s(read\_header);
1038         sam\_sq\_header.push\_back(pair<string,unsigned int>(s,len));
1039 
1040         \textcolor{keywordflow}{if} ( nt != EOF ) ungetc(nt,fp);
1041 
1042         full\_len+=len;
1043 
1044         \textcolor{comment}{/* if ( len > maxlen ) then ( maxlen = rrnalen ) else ( do nothing ) */}
1045         len > maxlen ? maxlen = len : maxlen;
1046 
1047     \} \textcolor{keywordflow}{while} ( nt != EOF ); \textcolor{comment}{/* read until end of file */}
1048     TIME(f);
1049 
1050     \textcolor{comment}{/* set file pointer back to the beginning of file */}
1051     rewind(fp);
1052 
1053     eprintf(\textcolor{stringliteral}{"  done  [%f sec]\(\backslash\)n"}, (f-s));
1054 
1055 
1056   \textcolor{comment}{/* STEP 1 END ****************************************************************************/}
1057 
1058 
1059 
1060 
1061 
1062 
1063   \textcolor{comment}{/* STEP 2 *******************************************************************************/}
1064     \textcolor{comment}{/* For every part of total index, (a) build the burst trie and set all 19-mer ids to 0}
1065 \textcolor{comment}{                                    (b) count the number of unique 19-mers in the database}
1066 \textcolor{comment}{                                    (c) output the unique 19-mers into a file for MPHF */}
1067 
1068     \textcolor{comment}{/* number of the index part */}
1069     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part = 0;
1070   \textcolor{comment}{/* starting position given by ftell() where to begin reading the reference sequences */}
1071     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} start\_part = 0;
1072     \textcolor{comment}{/* number of bytes of reference sequences to read */}
1073     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} seq\_part\_size = 0;
1074     \textcolor{comment}{/* total size of index so far in bytes */}
1075     \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} index\_size = 0;
1076 
1077     \textcolor{comment}{/* for each index part of the reference sequences */}
1078     \textcolor{keywordflow}{do}
1079     \{
1080         \textcolor{comment}{/* number of sequences in part size */}
1081         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numseq\_part = 0;
1082  
1083         \textcolor{comment}{/* set the file pointer to the beginning of the current part */}
1084         start\_part = ftell(fp);
1085 
1086         \textcolor{comment}{/* output file storing all s-mer (19-mer) words in the reference sequences,}
1087 \textcolor{comment}{             required for CMPH to build minimal perfect hash functions */}
1088         FILE *keys = fopen(\textcolor{stringliteral}{"keys.txt"}, \textcolor{stringliteral}{"w+"});
1089         \textcolor{keywordflow}{if} ( keys == NULL ) 
1090         \{
1091             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not open keys.txt file for writing\(\backslash\)n"});
1092             exit(EXIT\_FAILURE);
1093         \}
1094 
1095         \textcolor{comment}{/* count of unique 19-mers in database */}
1096         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} number\_elements = 0;
1097 
1098         \textcolor{comment}{/* table storing occurrence of each 9-mer and pointers to the forward and reverse burst tries */}
1099         kmer *lookup\_table = (kmer*)malloc((1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv})*\textcolor{keyword}{sizeof}(kmer));
1100         \textcolor{keywordflow}{if} ( lookup\_table == NULL )
1101         \{
1102             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for 9-mer look-up table (indexdb.cpp)\(\backslash\)n"});
1103             exit(EXIT\_FAILURE);
1104         \}
1105 
1106         memset(lookup\_table, 0, (1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv})*\textcolor{keyword}{sizeof}(kmer));    
1107 
1108         \textcolor{comment}{/* total size of index so far in bytes */}       
1109         index\_size = 0;
1110 
1111         eprintf(\textcolor{stringliteral}{"\(\backslash\)n  start index part # %d: \(\backslash\)n"},part);
1112 
1113         eprintf(\textcolor{stringliteral}{"    (1/3) building burst tries .."});
1114  
1115         TIME(s);
1116         \textcolor{comment}{/* for the number of sequences for which the index is less than maximum (set by -m) */}
1117         \textcolor{keywordflow}{do}
1118         \{
1119             \textcolor{comment}{/* start of current sequence in file */}
1120             \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} start\_seq = ftell(fp);
1121             nt = fgetc(fp);
1122 
1123             \textcolor{comment}{/* scan to end of header name */}
1124             \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'\(\backslash\)n'} ) nt = fgetc(fp);
1125 
1126             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* myseq = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}[maxlen];
1127             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* myseqr = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}[maxlen];
1128             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_j = 0;
1129             len = 0;
1130 
1131             nt = fgetc(fp);
1132             \textcolor{comment}{/* encode each sequence using integer alphabet \{0,1,2,3\} */}
1133             \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'>'} && nt != EOF )
1134             \{
1135                 \textcolor{comment}{/* skip line feed, carriage return or empty space in the sequence */}
1136                 \textcolor{keywordflow}{if} ( nt != \textcolor{charliteral}{'\(\backslash\)n'} && nt != \textcolor{charliteral}{' '} )
1137                 \{
1138                     len++;
1139                     \textcolor{comment}{/* exact character */}
1140                     myseq[\_j++] = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[nt];
1141                 \}
1142                 nt = fgetc(fp);
1143             \} 
1144 
1145 
1146             \textcolor{comment}{/* end of current sequence in file */}
1147             \textcolor{keywordflow}{if} ( nt != EOF ) ungetc(nt,fp);
1148 
1149             \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} end\_seq = ftell(fp);
1150 
1151             \textcolor{comment}{/* check the addition of this sequence will not overflow the maximum memory */}
1152             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} estimated\_seq\_mem = (\textcolor{keywordtype}{long} long)(len-\hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}+1)*90;
1153 
1154             \textcolor{comment}{/* the sequence alone is too large, it will not fit into maximum memory, skip it */}
1155             \textcolor{keywordflow}{if} ( estimated\_seq\_mem > mem )
1156             \{   
1157                 fseek(fp,start\_seq,SEEK\_SET);
1158                 fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  WARNING: the index for sequence `"});
1159                 \textcolor{keywordtype}{int} c = 0;
1160                 \textcolor{keywordflow}{do}
1161                 \{   
1162                     c = fgetc(fp);
1163                     fprintf(stderr,\textcolor{stringliteral}{"%c"},(\textcolor{keywordtype}{char})c);
1164                 \} \textcolor{keywordflow}{while} ( c != \textcolor{charliteral}{'\(\backslash\)n'} );
1165 
1166                 fprintf(stderr,\textcolor{stringliteral}{"` will not fit into %lld bytes memory, it will be skipped."},mem);
1167                 fprintf(stderr,\textcolor{stringliteral}{"  If memory can be increased, please try `-m %lld` bytes."},(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long})(len-
      \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}+1)*90);
1168                 fseek(fp,end\_seq,SEEK\_SET);
1169                 \textcolor{keywordflow}{continue};
1170             \}
1171             \textcolor{comment}{/* the additional sequence will overflow the maximum index memory, write existing index to disk
       and start a new index */}
1172             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( index\_size+estimated\_seq\_mem > mem )
1173             \{
1174                 \textcolor{comment}{/* set the character to something other than EOF */}
1175                 \textcolor{keywordflow}{if} ( nt == EOF ) nt = \textcolor{charliteral}{'A'};
1176 
1177                 \textcolor{comment}{/* reset the file pointer to the beginning of current sequence (which will be added to the
       next index part) */}
1178                 fseek(fp,start\_seq,SEEK\_SET);
1179 
1180                 \textcolor{keywordflow}{break};
1181             \}
1182             \textcolor{comment}{/* add the additional sequence to the index */}
1183             \textcolor{keywordflow}{else}
1184             \{
1185                 index\_size+=estimated\_seq\_mem;
1186 
1187                 \textcolor{comment}{/* record the number of bytes of raw reference sequences added to this part */}
1188                 seq\_part\_size = ftell(fp) - start\_part;
1189                 \textcolor{comment}{/* record the number of sequences in this part */}
1190                 numseq\_part++;
1191             \}
1192 
1193 
1194 
1195             \textcolor{comment}{/* create a reverse sequence using the forward */}
1196             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* ptr = &myseq[len-1];
1197 
1198             \textcolor{keywordflow}{for} ( \_j = 0; \_j < len; \_j++ )
1199                 myseqr[\_j] = *ptr--;
1200 
1201             \textcolor{comment}{/* the numerical values of 18-mers (and 9-mers) */}
1202             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} kmer\_key\_short = 0;
1203             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} kmer\_key = 0;
1204             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_ptr = &myseq[0];
1205             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_rev\_ptr = &myseqr[len-\hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-1];
1206 
1207             \textcolor{comment}{/* initialize the 19-mer */}
1208             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}; j++ )
1209                 (kmer\_key <<= 2) |= (int)*kmer\_key\_ptr++;
1210 
1211             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numwin = len - \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv} + 1;
1212 
1213             \textcolor{comment}{/* for all 19-mers on the sequence */}
1214             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < numwin; j++ )
1215             \{
1216                 \textcolor{comment}{/* the forward mini burst tries can be built until j = len-lnwin\_gv-1 */}
1217                 \textcolor{keywordflow}{if} ( j < len-\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} )
1218                 \{
1219                     \textcolor{comment}{/* intialize the first 9-mer (mask the 10-mer suffix of kmer\_id) */}
1220                     kmer\_key\_short = kmer\_key>>(pread\_gv+1);
1221 
1222                     lookup\_table[kmer\_key\_short].count++;
1223 
1224                     \textcolor{comment}{/* new position for 18-mer in positions\_tbl */}
1225                     \textcolor{keywordtype}{bool} new\_position = \textcolor{keyword}{true};
1226 
1227                     \textcolor{comment}{/* forward 19-mer does not exist in the burst trie */}
1228                     \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_F == NULL || 
1229                            ( (lookup\_table[kmer\_key\_short].trie\_F != NULL) && 
1230                                 !\hyperlink{indexdb_8cpp_ae12cbd742f045711033824302716453f}{search\_burst\_trie}( lookup\_table[kmer\_key\_short].trie\_F, (
      kmer\_key\_ptr-partialwin\_gv-1), new\_position ) ) )
1231                     \{
1232                         \textcolor{comment}{/* create a trie node if it doesn't exist */}
1233                         \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_F == NULL )
1234                         \{
1235                             lookup\_table[kmer\_key\_short].trie\_F = (NodeElement*)malloc(4*\textcolor{keyword}{sizeof}(NodeElement
      ));
1236                             \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_F == NULL )
1237                             \{
1238                                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for trie\_node in
       indexdb.cpp\(\backslash\)n"});
1239                                 exit(EXIT\_FAILURE);
1240                             \}
1241                             memset(lookup\_table[kmer\_key\_short].trie\_F, 0, 4*\textcolor{keyword}{sizeof}(NodeElement));
1242                         \}
1243 
1244                         \hyperlink{indexdb_8cpp_aadd596531a2498e4b29c228ecfe6341a}{insert\_prefix}( lookup\_table[kmer\_key\_short].trie\_F, (kmer\_key\_ptr-
      partialwin\_gv-1) );
1245                     \}
1246 
1247                     \textcolor{comment}{/* 18-mer doesn't exist in the burst trie, add it to keys file */}
1248                     \textcolor{keywordflow}{if} ( new\_position )
1249                     \{
1250                         \textcolor{comment}{/* increment number of unique 18-mers */}
1251                         number\_elements++;
1252 
1253                         fprintf(keys,\textcolor{stringliteral}{"%llu\(\backslash\)n"},(kmer\_key>>2));
1254                     \}
1255 
1256                     \textcolor{comment}{/* shift the 19-mer window (except for the last 19-mer window on the sequence) */}
1257                     \textcolor{keywordflow}{if} ( j < len-pread\_gv )
1258                         (( kmer\_key <<= 2 ) &= \hyperlink{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}{mask64} ) |= (int)*kmer\_key\_ptr++;
1259                     \textcolor{keywordflow}{else} kmer\_key\_ptr-=(partialwin\_gv+1);
1260 
1261                 \}
1262                 \textcolor{comment}{/* the reverse mini-burst tries can start to be built at j = partialwin\_gv+1 */}
1263                 \textcolor{keywordflow}{if} ( j > (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})\hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv} )
1264                 \{
1265                     \textcolor{keywordflow}{if} ( j > len-pread\_gv )
1266                     \{   
1267                         \textcolor{comment}{/* intialize the first 9-mer (mask the 10-mer suffix of kmer\_id) */}
1268                         (( kmer\_key\_short <<= 2 ) &= \hyperlink{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} ) |= (int)*kmer\_key\_ptr++;
1269 
1270                         lookup\_table[kmer\_key\_short].count++;
1271                     \}
1272 
1273                     \textcolor{keywordtype}{bool} new\_position = \textcolor{keyword}{true};
1274 
1275                     \textcolor{comment}{/* reverse 19-mer does not exist in the burst trie */}
1276                     \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_R == NULL || 
1277                            ( (lookup\_table[kmer\_key\_short].trie\_R != NULL) && 
1278                                 !\hyperlink{indexdb_8cpp_ae12cbd742f045711033824302716453f}{search\_burst\_trie}( lookup\_table[kmer\_key\_short].trie\_R, 
      kmer\_key\_rev\_ptr, new\_position ) ) )
1279                     \{
1280                         \textcolor{comment}{/* create a trie node if it doesn't exist */}
1281                         \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_R == NULL )
1282                         \{
1283                             lookup\_table[kmer\_key\_short].trie\_R = (NodeElement*)malloc(4*\textcolor{keyword}{sizeof}(NodeElement
      ));
1284                             \textcolor{keywordflow}{if} ( lookup\_table[kmer\_key\_short].trie\_R == NULL )
1285                             \{
1286                                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for trie\_node in
       indexdb.cpp\(\backslash\)n"});
1287                                 exit(EXIT\_FAILURE);
1288                             \}
1289                             memset(lookup\_table[kmer\_key\_short].trie\_R, 0, 4*\textcolor{keyword}{sizeof}(NodeElement));
1290                         \}
1291 
1292                         \hyperlink{indexdb_8cpp_aadd596531a2498e4b29c228ecfe6341a}{insert\_prefix}( lookup\_table[kmer\_key\_short].trie\_R, kmer\_key\_rev\_ptr )
      ;
1293                     \}
1294 
1295                     \textcolor{comment}{/* shift the reverse 19-mer window ptr */}
1296                     kmer\_key\_rev\_ptr--;
1297 
1298                 \}
1299 
1300             \}\textcolor{comment}{//~for all 19-mers on the sequence }
1301 
1302             \textcolor{keyword}{delete} [] myseq;
1303             \textcolor{keyword}{delete} [] myseqr;
1304 
1305         \} \textcolor{keywordflow}{while} ( nt != EOF ); \textcolor{comment}{/* all file */}
1306 
1307         TIME(f);
1308 
1309         \textcolor{comment}{/* no index can be created, all reference sequences are too large to fit alone into maximum memory 
      */}
1310         \textcolor{keywordflow}{if} ( index\_size == 0 )
1311         \{
1312             eprintf(\textcolor{stringliteral}{"\(\backslash\)n  ERROR: no index was created, all of your sequences are too large to be indexed
       with the current memory limit of %llu bytes.\(\backslash\)n"}, mem);
1313             \textcolor{keywordflow}{break};
1314         \}
1315         \textcolor{comment}{/* continue to build hash and positions tables */}
1316         \textcolor{keywordflow}{else}
1317             index\_size = 0;
1318 
1319         rewind(keys);
1320 
1321         eprintf(\textcolor{stringliteral}{" done  [%f sec]\(\backslash\)n"}, (f-s));
1322 
1323         \textcolor{comment}{/*  4. build MPHF on the unique 18-mers  */}
1324         eprintf(\textcolor{stringliteral}{"    (2/3) building CMPH hash .."});
1325         TIME(s);
1326         cmph\_t *hash = NULL;
1327 
1328         FILE * keys\_fd = keys;
1329         \textcolor{keywordflow}{if} (keys\_fd == NULL) 
1330         \{
1331         fprintf(stderr, \textcolor{stringliteral}{"File \(\backslash\)"keys.txt\(\backslash\)" not found\(\backslash\)n"});
1332         exit(EXIT\_FAILURE);
1333         \}   
1334         cmph\_io\_adapter\_t *source = cmph\_io\_nlfile\_adapter(keys\_fd);
1335 
1336         cmph\_config\_t *config = cmph\_config\_new(source);
1337         cmph\_config\_set\_algo(config, CMPH\_CHM);
1338         hash = cmph\_new(config);
1339         cmph\_config\_destroy(config);
1340     
1341         \textcolor{comment}{/* Destroy file adapter */}
1342         cmph\_io\_nlfile\_adapter\_destroy(source);   
1343         fclose(keys\_fd);
1344     
1345         TIME(f);
1346 
1347         eprintf(\textcolor{stringliteral}{" done  [%f sec]\(\backslash\)n"}, (f-s));
1348 
1349         \textcolor{keywordtype}{int} ret = system(\textcolor{stringliteral}{"rm keys.txt"});
1350         \textcolor{keywordflow}{if} ( ret != 0 )
1351         \{
1352             fprintf(stderr, \textcolor{stringliteral}{"  WARNING: could not delete temporary file keys.txt in current folder\(\backslash\)n"});
1353         \}
1354         
1355 
1356         \textcolor{comment}{/*  5. add ids to burst trie}
1357 \textcolor{comment}{                6. build the positions lookup table using MPHF  */}
1358 
1359         eprintf(\textcolor{stringliteral}{"    (3/3) building position lookup tables .."});
1360 
1361         \textcolor{comment}{/* positions\_tbl[kmer\_id] will return a pointer to an array of pairs, each pair}
1362 \textcolor{comment}{            stores the sequence number and index on the sequence of the kmer\_id 19-mer */}
1363         kmer\_origin* positions\_tbl = NULL;
1364 
1365         positions\_tbl = (kmer\_origin*)malloc(number\_elements*\textcolor{keyword}{sizeof}(kmer\_origin));
1366         \textcolor{keywordflow}{if} ( positions\_tbl == NULL )
1367         \{
1368             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for positions\_tbl (main(), indexdb.cpp)\(\backslash\)n"});
1369             exit(EXIT\_FAILURE);
1370         \}
1371 
1372         memset(positions\_tbl, 0, number\_elements*\textcolor{keyword}{sizeof}(kmer\_origin));
1373 
1374         \textcolor{comment}{/* sequence number */}
1375         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; 
1376 
1377         \textcolor{comment}{/* reset the file pointer to the beginning of the current part */}
1378         fseek(fp,start\_part,SEEK\_SET);
1379 
1380 
1381         TIME(s);
1382         \textcolor{keywordflow}{do}
1383         \{ 
1384             \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} start\_seq = ftell(fp);
1385             nt = fgetc(fp);
1386 
1387             \textcolor{comment}{/* scan to end of header name */}
1388             \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'\(\backslash\)n'}) nt = fgetc(fp);
1389 
1390             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* myseq = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}[maxlen];
1391             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* myseqr = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}[maxlen];
1392             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \_j = 0;
1393             len = 0;
1394 
1395             \textcolor{comment}{/* encode each sequence using integer alphabet \{0,1,2,3\} */}
1396             nt = fgetc(fp);
1397             \textcolor{keywordflow}{while} ( nt != \textcolor{charliteral}{'>'} && nt != EOF )
1398             \{
1399                 \textcolor{comment}{/* skip line feed, carriage return or empty space in the sequence */}
1400                 \textcolor{keywordflow}{if} ( nt != \textcolor{charliteral}{'\(\backslash\)n'} && nt != \textcolor{charliteral}{' '} )
1401                 \{
1402                     len++;
1403                     \textcolor{comment}{/* exact character */}
1404                     myseq[\_j++] = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[nt];
1405                 \}
1406                 nt = fgetc(fp);
1407             \} 
1408 
1409             \textcolor{comment}{/* put back the > */}
1410             \textcolor{keywordflow}{if} ( nt != EOF ) ungetc(nt,fp);
1411 
1412 
1413             \textcolor{comment}{/* check the addition of this sequence will not overflow the maximum memory */}
1414             \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} estimated\_seq\_mem = (\textcolor{keywordtype}{long} long)(len-pread\_gv+1)*90;
1415 
1416             \textcolor{comment}{/* the sequence alone is too large, it will not fit into maximum memory, skip it */}
1417             \textcolor{keywordflow}{if} ( estimated\_seq\_mem > mem ) \textcolor{keywordflow}{continue}; 
1418             \textcolor{comment}{/* the additional sequence will overflow the maximum index memory, write existing index to disk
       and start a new index */}
1419             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( index\_size+estimated\_seq\_mem > mem )
1420             \{
1421                 \textcolor{comment}{/* set the character to something other than EOF */}
1422                 \textcolor{keywordflow}{if} ( nt == EOF ) nt = \textcolor{charliteral}{'A'};
1423 
1424                 \textcolor{comment}{/* scan back to start of sequence for next index part */}
1425                 fseek(fp,start\_seq,SEEK\_SET);
1426                 \textcolor{keywordflow}{break};
1427             \}
1428             \textcolor{comment}{/* add the additional sequence to the index */}
1429             \textcolor{keywordflow}{else}
1430             \{
1431                 index\_size+=estimated\_seq\_mem;
1432             \}
1433 
1434 
1435             \textcolor{comment}{/* create a reverse sequence using the forward */}
1436             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* ptr = &myseq[len-1];
1437 
1438             \textcolor{keywordflow}{for} ( \_j = 0; \_j < len; \_j++ )
1439                 myseqr[\_j] = *ptr--;
1440 
1441             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} kmer\_key\_short\_f = 0;
1442             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} kmer\_key\_short\_r = 0;
1443             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_short\_f\_p = &myseq[0];
1444             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_short\_r\_p = &myseq[partialwin\_gv+1];
1445             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_short\_r\_rp = &myseqr[len-partialwin\_gv-1];
1446 
1447             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} kmer\_key = 0;
1448             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* kmer\_key\_ptr = &myseq[0];
1449 
1450             \textcolor{comment}{/* initialize the 9-mers */}
1451             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}; j++ )
1452             \{
1453                 (kmer\_key\_short\_f <<= 2) |= (\textcolor{keywordtype}{int})*kmer\_key\_short\_f\_p++;
1454                 (kmer\_key\_short\_r <<= 2) |= (\textcolor{keywordtype}{int})*kmer\_key\_short\_r\_p++;
1455             \}
1456 
1457             \textcolor{comment}{/* initialize the 19-mer */}
1458             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < \hyperlink{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv}; j++ )
1459                 (kmer\_key <<= 2) |= (int)*kmer\_key\_ptr++;
1460 
1461             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numwin = len - pread\_gv + 1;
1462             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} \textcolor{keywordtype}{id} = 0;
1463 
1464             \textcolor{comment}{/* for all 19-mers on the sequence */}
1465             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < numwin; j++ )
1466             \{
1467                 sprintf(a,\textcolor{stringliteral}{"%llu"},(kmer\_key>>2));
1468                 \textcolor{keyword}{const} \textcolor{keywordtype}{char} *key = a;
1469                 \textcolor{keywordtype}{id} = cmph\_search(hash, key, (cmph\_uint32)strlen(key));
1470 
1471                 \hyperlink{indexdb_8cpp_a5c706351c5ed7142c97507cbcb108d0e}{add\_id\_to\_burst\_trie}( lookup\_table[kmer\_key\_short\_f].trie\_F, 
      kmer\_key\_short\_f\_p, \textcolor{keywordtype}{id} );
1472                 \hyperlink{indexdb_8cpp_a5c706351c5ed7142c97507cbcb108d0e}{add\_id\_to\_burst\_trie}( lookup\_table[kmer\_key\_short\_r].trie\_R, 
      kmer\_key\_short\_r\_rp, \textcolor{keywordtype}{id} );
1473 
1474                 \hyperlink{indexdb_8cpp_af3b09b38f41c15440498b0dcfe6239af}{add\_kmer\_to\_table}( positions\_tbl+\textcolor{keywordtype}{id}, i, j );
1475 
1476 
1477                 \textcolor{comment}{/* shift the keys */}
1478                 \textcolor{keywordflow}{if} ( j != numwin-1 )
1479                 \{
1480                     (( kmer\_key\_short\_f <<= 2 ) &= \hyperlink{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} ) |= (int)*kmer\_key\_short\_f\_p++;
1481                     (( kmer\_key\_short\_r <<= 2 ) &= \hyperlink{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} ) |= (int)*kmer\_key\_short\_r\_p++;
1482                     (( kmer\_key <<= 2 ) &= \hyperlink{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}{mask64} ) |= (int)*kmer\_key\_ptr++;
1483                     kmer\_key\_short\_r\_rp--;
1484                 \}
1485             \}
1486 
1487             \textcolor{keyword}{delete} [] myseq;
1488             \textcolor{keyword}{delete} [] myseqr;
1489 
1490             \textcolor{comment}{/* next sequence */}
1491             i++;
1492 
1493         \} \textcolor{keywordflow}{while} ( nt != EOF ); \textcolor{comment}{/* for all file */}
1494 
1495 
1496         TIME(f);
1497         eprintf(\textcolor{stringliteral}{" done [%f sec]\(\backslash\)n"}, (f-s));
1498 
1499         eprintf(\textcolor{stringliteral}{"    total number of sequences in this part = %d\(\backslash\)n"},i);
1500 
1501         \textcolor{comment}{/* Destroy hash */}
1502         cmph\_destroy(hash);
1503 
1504 
1505 
1506     
1507 
1508 
1509         \textcolor{comment}{/* Load constructed index part to binary file */}
1510 
1511         \textcolor{comment}{/* covert part number into a string */}
1512         stringstream prt\_str;
1513         prt\_str << part;
1514         \textcolor{keywordtype}{string} part\_str = prt\_str.str();
1515 
1516         \textcolor{comment}{/* 1. load the kmer 'count' variable /index/kmer.dat */}
1517         ofstream oskmer ( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".kmer\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str(), 
      ios::binary );
1518         eprintf(\textcolor{stringliteral}{"      writing kmer data to %s\(\backslash\)n"},(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".kmer\_"} + part\_str + \textcolor{stringliteral}{".dat"}).
      c\_str());
1519 
1520         \textcolor{comment}{/* the start position in the file where the sequences for this burst trie begin */}
1521         oskmer.write(reinterpret\_cast<const char*>(&start\_part), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int}));
1522 
1523         \textcolor{comment}{/* the number of sequences to load (in bytes) */}
1524         oskmer.write(reinterpret\_cast<const char*>(&seq\_part\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int}));
1525 
1526         \textcolor{comment}{/* the number of sequences in this part */}
1527         oskmer.write(reinterpret\_cast<const char*>(&numseq\_part), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1528 
1529         \textcolor{comment}{/* the 9-mer look up tables */}
1530         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < (1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}); j++ )
1531         \{
1532             oskmer.write(reinterpret\_cast<const char*>(&(lookup\_table[j].count)), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1533         \}
1534 
1535         oskmer.close();
1536 
1537         \textcolor{comment}{/* 2. mini-burst tries */}
1538 
1539         \textcolor{comment}{/* load 9-mer look-up table and mini-burst tries to /index/bursttrief.dat */}
1540         eprintf(\textcolor{stringliteral}{"      writing burst tries to %s\(\backslash\)n"},(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".bursttrie\_"} + part\_str + \textcolor{stringliteral}{"
      .dat"}).c\_str()); 
1541         \hyperlink{indexdb_8cpp_a7743cfb5e362845d7a4c2ba708457506}{load\_index}( lookup\_table, (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".bursttrie\_"} + part\_str + \textcolor{stringliteral}{"
      .dat"}).c\_str() );
1542 
1543         \textcolor{comment}{/* 3. 19-mer position look up tables */}
1544         ofstream ospos ( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".pos\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str(), 
      ios::binary );
1545         eprintf(\textcolor{stringliteral}{"      writing position lookup table to %s\(\backslash\)n"},(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".pos\_"} + part\_str
       + \textcolor{stringliteral}{".dat"}).c\_str()); 
1546 
1547         \textcolor{comment}{/* number of unique 19-mers */}
1548         ospos.write(reinterpret\_cast<const char*>(&number\_elements), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1549 
1550         \textcolor{comment}{/* the positions */}
1551         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < (int)number\_elements; j++ )
1552         \{
1553             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size = positions\_tbl[j].size;
1554 
1555             ospos.write(reinterpret\_cast<const char*>(&size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1556             ospos.write(reinterpret\_cast<const char*>(positions\_tbl[j].arr), \textcolor{keyword}{sizeof}(seq\_pos)*size);
1557         \}
1558         ospos.close();
1559 
1560         
1561         \textcolor{comment}{/* Free malloc'd memory */}
1562         \textcolor{comment}{/* Table of unique 19-mer positions */}
1563         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} z = 0; z < (int)number\_elements; z++ )
1564             free(positions\_tbl[z].arr);
1565         free(positions\_tbl);
1566 
1567 
1568         \textcolor{comment}{/* 9-mer look-up table and mini-burst tries */}
1569         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} z = 0; z < (1<<\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}); z++ )
1570         \{
1571             \textcolor{keywordflow}{if} (lookup\_table[z].trie\_F != NULL )
1572             \{
1573                 \hyperlink{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}{freebursttrie}(lookup\_table[z].trie\_F);
1574                 free(lookup\_table[z].trie\_F);
1575             \}
1576             \textcolor{keywordflow}{if} (lookup\_table[z].trie\_R != NULL )
1577             \{
1578                 \hyperlink{indexdb_8cpp_a0db773c8c3fab8a1ff1a779dff5db274}{freebursttrie}(lookup\_table[z].trie\_R);
1579                 free(lookup\_table[z].trie\_R);       
1580             \}
1581         \}
1582 
1583         free(lookup\_table);
1584 
1585         part++;
1586 
1587     \} \textcolor{keywordflow}{while} ( nt != EOF ); \textcolor{comment}{/* for all index parts */}
1588 
1589     \textcolor{keywordflow}{if} ( index\_size != 0 )
1590     \{
1591         eprintf(\textcolor{stringliteral}{"      writing SAM header and nucleotide distribution statistics to %s\(\backslash\)n"},(path + \textcolor{stringliteral}{"/index/"}
       + root + \textcolor{stringliteral}{".stats"}).c\_str()); 
1592         ofstream stats ( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".stats"}).c\_str(), ios::binary );
1593 
1594         \textcolor{comment}{/* SQ header for reference sequences (since in sortmedna, they are only loaded by section) */}
1595 
1596         \textcolor{comment}{/* number of sequences in the reference file */}
1597         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num\_sq = sam\_sq\_header.size();
1598         stats.write(reinterpret\_cast<const char*>(&num\_sq), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1599 
1600         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < (int)sam\_sq\_header.size(); j++ )
1601         \{
1602             \textcolor{comment}{/* length of the sequence id */}
1603             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len\_id = sam\_sq\_header[j].first.length();
1604             stats.write(reinterpret\_cast<const char*>(&len\_id), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1605 
1606             \textcolor{comment}{/* the sequence id */}
1607             stats.write(reinterpret\_cast<const char*>(&(sam\_sq\_header[j].first[0])), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})*len\_id);
1608 
1609             \textcolor{comment}{/* the length of the sequence itself */}
1610             stats.write(reinterpret\_cast<const char*>(&(sam\_sq\_header[j].second)), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1611         \}
1612 
1613         \textcolor{comment}{/* background frequencies, size of the database, window length and number of reference sequences in
       a separate stats file */}
1614 
1615         \textcolor{keywordtype}{double} total\_nt = background\_freq[0] + background\_freq[1] + background\_freq[2] + background\_freq[3]
      ;
1616 
1617         background\_freq[0] = background\_freq[0]/total\_nt;
1618         background\_freq[1] = background\_freq[1]/total\_nt;
1619         background\_freq[2] = background\_freq[2]/total\_nt;
1620         background\_freq[3] = background\_freq[3]/total\_nt;
1621 
1622         \textcolor{comment}{/* add the A/C/G/T percentage distribution */}
1623         stats.write(reinterpret\_cast<const char*>(&background\_freq), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double})*4); 
1624 
1625         \textcolor{comment}{/* add the size of the database */}
1626         stats.write(reinterpret\_cast<const char*>(&full\_len), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}));
1627 
1628         \textcolor{comment}{/* add the value of the sliding window length */}
1629         stats.write(reinterpret\_cast<const char*>(&\hyperlink{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
1630 
1631         \hyperlink{indexdb_8cpp_a07767ad55883c155321a7f7035d24eeb}{numseq\_gv} = (int)strs/2;
1632 
1633         \textcolor{comment}{/* add the value of number of reference sequences */}
1634         stats.write(reinterpret\_cast<const char*>(&\hyperlink{indexdb_8cpp_a07767ad55883c155321a7f7035d24eeb}{numseq\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
1635 
1636         \textcolor{comment}{/* number of index parts */}
1637         stats.write(reinterpret\_cast<const char*>(&part), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
1638 
1639         stats.close();
1640 
1641         eprintf(\textcolor{stringliteral}{"    done.\(\backslash\)n"});
1642     \}
1643 
1644 
1645     \textcolor{comment}{/* Free map'd memory */}
1646     fclose(fp);
1647 
1648     \textcolor{keywordflow}{return} 0;
1649 
1650 \}\textcolor{comment}{//~main}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}{\index{indexdb.\-cpp@{indexdb.\-cpp}!printlist@{printlist}}
\index{printlist@{printlist}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{printlist}]{\setlength{\rightskip}{0pt plus 5cm}void printlist (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a0941557dba62d9c3a5c48205b6a76f85}

\begin{DoxyCode}
709 \{
710     printf(\textcolor{stringliteral}{"\(\backslash\)n  program:     indexdb\(\backslash\)n"});
711   printf(\textcolor{stringliteral}{"  description: index a genome or a database of reference sequences,        \(\backslash\)n"});
712     printf(\textcolor{stringliteral}{"               (the binary index is stored under the folder '/sortmedna/index') \(\backslash\)n"});
713     printf(\textcolor{stringliteral}{"  usage:       ./indexdb --ref [path to genome or database file name \{.fasta\}] <options>\(\backslash\)n\(\backslash\)n"});
714   printf(\textcolor{stringliteral}{"  parameter        value     description                                              default\(\backslash\)n"})
      ;
715   printf(\textcolor{stringliteral}{"  -------------------------------------------------------------------------------------------\(\backslash\)n"})
      ;
716   printf(\textcolor{stringliteral}{"  <options>:\(\backslash\)n"});          
717   printf(\textcolor{stringliteral}{"   %s--fast%s          %sFLAG%s      suggested option for aligning ~99%% related species        
       %soff%s\(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
718     printf(\textcolor{stringliteral}{"   %s--sensitive%s     %sFLAG%s      suggested option for aligning ~75-98%% related species    
        %son%s\(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
719   printf(\textcolor{stringliteral}{"   %s-m%s              %sINT%s       the amount of memory (in bytes) for constructing an index 
       %s3GB%s \(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
720     printf(\textcolor{stringliteral}{"   %s-L%s              %sINT%s       seed length                                               
       %s18%s\(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
721     printf(\textcolor{stringliteral}{"   %s-v%s              %sFLAG%s      verbose\(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
722     printf(\textcolor{stringliteral}{"   %s-h%s              %sFLAG%s      help   \(\backslash\)n\(\backslash\)n"},\textcolor{stringliteral}{"\(\backslash\)033[1m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"},\textcolor{stringliteral}{"\(\backslash\)033[4m"},\textcolor{stringliteral}{"\(\backslash\)033[0m"});
723     exit(EXIT\_FAILURE);
724 \}\textcolor{comment}{//~printlist()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_ae12cbd742f045711033824302716453f}{\index{indexdb.\-cpp@{indexdb.\-cpp}!search\-\_\-burst\-\_\-trie@{search\-\_\-burst\-\_\-trie}}
\index{search\-\_\-burst\-\_\-trie@{search\-\_\-burst\-\_\-trie}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{search\-\_\-burst\-\_\-trie}]{\setlength{\rightskip}{0pt plus 5cm}bool search\-\_\-burst\-\_\-trie (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-node, }
\item[{unsigned char $\ast$}]{kmer\-\_\-short\-\_\-key, }
\item[{bool \&}]{new\-\_\-position}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_ae12cbd742f045711033824302716453f}

\begin{DoxyCode}
367 \{
368     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} depth = 0;
369 
370     \textcolor{comment}{/* find a terminal trie node */}
371     NodeElement *node\_elem = (NodeElement*)(trie\_node + *kmer\_short\_key++);
372     depth++;
373 
374     \textcolor{keywordflow}{while} ( node\_elem->flag == 1 )
375     \{
376         trie\_node = node\_elem->whichnode.trie;
377         node\_elem = (NodeElement*)(trie\_node + *kmer\_short\_key++);
378         depth++;
379     \} 
380 
381     \textcolor{keywordflow}{if} ( node\_elem->flag == 0 )
382         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
383         
384     \textcolor{comment}{/* encode the remaining part of kmer\_short\_key using 4 nt per byte */}
385     \textcolor{keywordtype}{int} s = \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}+1-depth;
386 
387     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} encode = 0;
388     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < s; i++ )
389     \{
390         encode |= ((\textcolor{keywordtype}{unsigned} int)*kmer\_short\_key++)<<(2*i);
391     \}
392 
393     \textcolor{comment}{/* size of entry in a bucket */}
394     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* start\_bucket = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)node\_elem->whichnode.bucket;          
395     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* end\_bucket = start\_bucket + node\_elem->size;
396 
397     \textcolor{comment}{/* to mask the last nucleotide of 19-mer */}
398     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} msk = (1<<(2*(s-1)))-1;
399 
400     \textcolor{comment}{/* compare the 1 int representation of kmer\_id\_short\_F with all}
401 \textcolor{comment}{            elements in the bucket */}
402     \textcolor{keywordflow}{while} ( start\_bucket != end\_bucket )
403     \{
404         \textcolor{comment}{/* 18-mer found */}
405         \textcolor{keywordflow}{if} ( (encode&msk) == (*((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket)&msk ) )
406         \{
407             new\_position = \textcolor{keyword}{false};
408             \textcolor{comment}{/* 19-mer found */}
409             \textcolor{keywordflow}{if} ( encode == *((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket) )
410                 \textcolor{keywordflow}{return} \textcolor{keyword}{true};
411         \}
412         start\_bucket+=\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
413     \}
414 
415     \textcolor{comment}{/* end of bucket reached, 19-mer not found */}
416     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
417     
418 \}\textcolor{comment}{//~search\_burst\_trie()}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a11ea4ace169605656dcd2ddc58f86de0}{\index{indexdb.\-cpp@{indexdb.\-cpp}!traversetrie@{traversetrie}}
\index{traversetrie@{traversetrie}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{traversetrie}]{\setlength{\rightskip}{0pt plus 5cm}void traversetrie (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-node, }
\item[{unsigned int}]{depth}
\end{DoxyParamCaption}
)}}\label{indexdb_8cpp_a11ea4ace169605656dcd2ddc58f86de0}

\begin{DoxyCode}
494 \{
495     \hyperlink{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}{total\_num\_trie\_nodes}++;
496 
497     \textcolor{comment}{/* traverse through the node elements in a trie node */}
498     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
499     \{
500         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} value = trie\_node->flag;
501 
502         \textcolor{comment}{/* the node element holds a pointer to another trie node */}
503         \textcolor{keywordflow}{if} ( value == 1 )
504         \{ 
505             \hyperlink{indexdb_8cpp_a11ea4ace169605656dcd2ddc58f86de0}{traversetrie}( trie\_node->whichnode.trie, ++depth );
506             --depth;
507         \}
508 
509         \textcolor{comment}{/* the node element points to a bucket */}
510         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( value == 2 )
511         \{
512             \textcolor{comment}{/* pad to alignment length (16-byte line) */}
513             \textcolor{comment}{//int padding = 16-((trie\_node->size)%16);}
514             \textcolor{comment}{//size\_of\_all\_buckets+=(trie\_node->size + padding);}
515             \hyperlink{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}{size\_of\_all\_buckets}+=trie\_node->size;
516 
517             \textcolor{comment}{/* for STATISTICS */}
518             \hyperlink{indexdb_8cpp_afee2e2e3b31ffc24935f729aa445c174}{total\_num\_buckets}++; 
519             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} s = \hyperlink{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-depth;
520 
521             \textcolor{keywordflow}{if} ( s > \hyperlink{indexdb_8cpp_a31e084acc6c5e53fc19a7aaacbcb9b63}{longest\_elem\_in\_bucket} )
522                 \hyperlink{indexdb_8cpp_a31e084acc6c5e53fc19a7aaacbcb9b63}{longest\_elem\_in\_bucket} = s;
523             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( s < \hyperlink{indexdb_8cpp_a1b90ed1106778af012d3402a66de1e45}{shortest\_elem\_in\_bucket} )  
524                 \hyperlink{indexdb_8cpp_a1b90ed1106778af012d3402a66de1e45}{shortest\_elem\_in\_bucket} = s;
525 
526             \hyperlink{indexdb_8cpp_ab52f265ad9d023c852bf5c424d35670a}{all\_lengths\_elements\_in\_buckets}+=s;
527 
528             \hyperlink{indexdb_8cpp_a0a9cef6c669464bde4a09196192d043f}{avg\_len}[s]++;
529 
530             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} numelem = (trie\_node->size)/\hyperlink{indexdb_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
531 
532             \textcolor{keywordflow}{if} ( numelem > \hyperlink{indexdb_8cpp_aaccb835f1b80ee0a9f2ca20d858bbb35}{high\_num\_elem\_in\_bucket} ) 
533                 \hyperlink{indexdb_8cpp_aaccb835f1b80ee0a9f2ca20d858bbb35}{high\_num\_elem\_in\_bucket} = numelem;
534             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( numelem < \hyperlink{indexdb_8cpp_a1570d01ca7eadb4a7e458b61cbd9b9dc}{low\_num\_elem\_in\_bucket} )
535                 \hyperlink{indexdb_8cpp_a1570d01ca7eadb4a7e458b61cbd9b9dc}{low\_num\_elem\_in\_bucket} = numelem;
536 
537             \hyperlink{indexdb_8cpp_ab5717b1f88f08cc3d1dd58ad50efc222}{all\_elem\_in\_buckets}+=numelem;
538 
539             \hyperlink{indexdb_8cpp_a86be46befd57f331a8f028e2d9571152}{num\_elem}[numelem]++;
540 
541             \textcolor{comment}{/* end for STATISTICS */}
542         \}
543 
544         \textcolor{comment}{/* the node element is empty, go to next node element */}
545         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( value == 0 ) 
546         \{ 
547             ;
548         \}
549 
550         trie\_node++; 
551 
552     \}\textcolor{comment}{//~trie nodes}
553 
554     \textcolor{keywordflow}{return};
555 
556 \}\textcolor{comment}{//~taversetrie()}
\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{indexdb_8cpp_ab5717b1f88f08cc3d1dd58ad50efc222}{\index{indexdb.\-cpp@{indexdb.\-cpp}!all\-\_\-elem\-\_\-in\-\_\-buckets@{all\-\_\-elem\-\_\-in\-\_\-buckets}}
\index{all\-\_\-elem\-\_\-in\-\_\-buckets@{all\-\_\-elem\-\_\-in\-\_\-buckets}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{all\-\_\-elem\-\_\-in\-\_\-buckets}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int all\-\_\-elem\-\_\-in\-\_\-buckets = 0}}\label{indexdb_8cpp_ab5717b1f88f08cc3d1dd58ad50efc222}
\hypertarget{indexdb_8cpp_ab52f265ad9d023c852bf5c424d35670a}{\index{indexdb.\-cpp@{indexdb.\-cpp}!all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets@{all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets}}
\index{all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets@{all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int all\-\_\-lengths\-\_\-elements\-\_\-in\-\_\-buckets = 0}}\label{indexdb_8cpp_ab52f265ad9d023c852bf5c424d35670a}
\hypertarget{indexdb_8cpp_a0a9cef6c669464bde4a09196192d043f}{\index{indexdb.\-cpp@{indexdb.\-cpp}!avg\-\_\-len@{avg\-\_\-len}}
\index{avg\-\_\-len@{avg\-\_\-len}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{avg\-\_\-len}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int avg\-\_\-len\mbox{[}11\mbox{]} = \{0\}}}\label{indexdb_8cpp_a0a9cef6c669464bde4a09196192d043f}
\hypertarget{indexdb_8cpp_aaccb835f1b80ee0a9f2ca20d858bbb35}{\index{indexdb.\-cpp@{indexdb.\-cpp}!high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket@{high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}}
\index{high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket@{high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int high\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket = 0}}\label{indexdb_8cpp_aaccb835f1b80ee0a9f2ca20d858bbb35}
\hypertarget{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{\index{indexdb.\-cpp@{indexdb.\-cpp}!lnwin\-\_\-gv@{lnwin\-\_\-gv}}
\index{lnwin\-\_\-gv@{lnwin\-\_\-gv}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{lnwin\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int lnwin\-\_\-gv = -\/1}}\label{indexdb_8cpp_ae5afe6be7bd736d06d763ff7822a824b}
\hypertarget{indexdb_8cpp_a31e084acc6c5e53fc19a7aaacbcb9b63}{\index{indexdb.\-cpp@{indexdb.\-cpp}!longest\-\_\-elem\-\_\-in\-\_\-bucket@{longest\-\_\-elem\-\_\-in\-\_\-bucket}}
\index{longest\-\_\-elem\-\_\-in\-\_\-bucket@{longest\-\_\-elem\-\_\-in\-\_\-bucket}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{longest\-\_\-elem\-\_\-in\-\_\-bucket}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int longest\-\_\-elem\-\_\-in\-\_\-bucket = 0}}\label{indexdb_8cpp_a31e084acc6c5e53fc19a7aaacbcb9b63}
\hypertarget{indexdb_8cpp_a1570d01ca7eadb4a7e458b61cbd9b9dc}{\index{indexdb.\-cpp@{indexdb.\-cpp}!low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket@{low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}}
\index{low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket@{low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int low\-\_\-num\-\_\-elem\-\_\-in\-\_\-bucket = 1000}}\label{indexdb_8cpp_a1570d01ca7eadb4a7e458b61cbd9b9dc}
\hypertarget{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{\index{indexdb.\-cpp@{indexdb.\-cpp}!map\-\_\-nt@{map\-\_\-nt}}
\index{map\-\_\-nt@{map\-\_\-nt}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{map\-\_\-nt}]{\setlength{\rightskip}{0pt plus 5cm}const char map\-\_\-nt\mbox{[}122\mbox{]}}}\label{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}
{\bfseries Initial value\-:}
\begin{DoxyCode}
= \{
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    
          0,   0,   0,   0,   0,   0,   1,   1,   1,   0,
    
          0,   2,   0,   0,   0,   2,   0,   0,   0,   0,
    
          0,   0,   0,   2,   3,   3,   0,   1,   2,   1,
    
          0,   0,   0,   0,   0,   0,   0,   0,   1,   1,
    
          0,   0,   0,   2,   0,   0,   0,   2,   0,   0,
    
          0,   0,   0,   0,   0,   2,   3,   3,   0,   1,
    
          2,   1\}
\end{DoxyCode}
\hypertarget{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{\index{indexdb.\-cpp@{indexdb.\-cpp}!mask32@{mask32}}
\index{mask32@{mask32}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{mask32}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int mask32 = 0}}\label{indexdb_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}
\hypertarget{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}{\index{indexdb.\-cpp@{indexdb.\-cpp}!mask64@{mask64}}
\index{mask64@{mask64}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{mask64}]{\setlength{\rightskip}{0pt plus 5cm}uint64\-\_\-t mask64 = 0}}\label{indexdb_8cpp_a9c67ae5a9dfa79f23dc819ac5b474a7c}
\hypertarget{indexdb_8cpp_a86be46befd57f331a8f028e2d9571152}{\index{indexdb.\-cpp@{indexdb.\-cpp}!num\-\_\-elem@{num\-\_\-elem}}
\index{num\-\_\-elem@{num\-\_\-elem}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{num\-\_\-elem}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int num\-\_\-elem\mbox{[}100\mbox{]} = \{0\}}}\label{indexdb_8cpp_a86be46befd57f331a8f028e2d9571152}
\hypertarget{indexdb_8cpp_a07767ad55883c155321a7f7035d24eeb}{\index{indexdb.\-cpp@{indexdb.\-cpp}!numseq\-\_\-gv@{numseq\-\_\-gv}}
\index{numseq\-\_\-gv@{numseq\-\_\-gv}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{numseq\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int numseq\-\_\-gv = 0}}\label{indexdb_8cpp_a07767ad55883c155321a7f7035d24eeb}
\hypertarget{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{\index{indexdb.\-cpp@{indexdb.\-cpp}!partialwin\-\_\-gv@{partialwin\-\_\-gv}}
\index{partialwin\-\_\-gv@{partialwin\-\_\-gv}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{partialwin\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int partialwin\-\_\-gv = -\/1}}\label{indexdb_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}
\hypertarget{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{\index{indexdb.\-cpp@{indexdb.\-cpp}!pread\-\_\-gv@{pread\-\_\-gv}}
\index{pread\-\_\-gv@{pread\-\_\-gv}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{pread\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int pread\-\_\-gv = -\/1}}\label{indexdb_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}
\hypertarget{indexdb_8cpp_a1b90ed1106778af012d3402a66de1e45}{\index{indexdb.\-cpp@{indexdb.\-cpp}!shortest\-\_\-elem\-\_\-in\-\_\-bucket@{shortest\-\_\-elem\-\_\-in\-\_\-bucket}}
\index{shortest\-\_\-elem\-\_\-in\-\_\-bucket@{shortest\-\_\-elem\-\_\-in\-\_\-bucket}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{shortest\-\_\-elem\-\_\-in\-\_\-bucket}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int shortest\-\_\-elem\-\_\-in\-\_\-bucket = 1000}}\label{indexdb_8cpp_a1b90ed1106778af012d3402a66de1e45}
\hypertarget{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}{\index{indexdb.\-cpp@{indexdb.\-cpp}!size\-\_\-of\-\_\-all\-\_\-buckets@{size\-\_\-of\-\_\-all\-\_\-buckets}}
\index{size\-\_\-of\-\_\-all\-\_\-buckets@{size\-\_\-of\-\_\-all\-\_\-buckets}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{size\-\_\-of\-\_\-all\-\_\-buckets}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int size\-\_\-of\-\_\-all\-\_\-buckets = 0}}\label{indexdb_8cpp_adc3b2cfebed76e9b637e0ea2cb94398a}
\hypertarget{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}{\index{indexdb.\-cpp@{indexdb.\-cpp}!sizeoftrie@{sizeoftrie}}
\index{sizeoftrie@{sizeoftrie}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{sizeoftrie}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int sizeoftrie = 0}}\label{indexdb_8cpp_ae3a215661f7bb843893140536f9d7c92}
\hypertarget{indexdb_8cpp_afee2e2e3b31ffc24935f729aa445c174}{\index{indexdb.\-cpp@{indexdb.\-cpp}!total\-\_\-num\-\_\-buckets@{total\-\_\-num\-\_\-buckets}}
\index{total\-\_\-num\-\_\-buckets@{total\-\_\-num\-\_\-buckets}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{total\-\_\-num\-\_\-buckets}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int total\-\_\-num\-\_\-buckets = 0}}\label{indexdb_8cpp_afee2e2e3b31ffc24935f729aa445c174}
\hypertarget{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}{\index{indexdb.\-cpp@{indexdb.\-cpp}!total\-\_\-num\-\_\-trie\-\_\-nodes@{total\-\_\-num\-\_\-trie\-\_\-nodes}}
\index{total\-\_\-num\-\_\-trie\-\_\-nodes@{total\-\_\-num\-\_\-trie\-\_\-nodes}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{total\-\_\-num\-\_\-trie\-\_\-nodes}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int total\-\_\-num\-\_\-trie\-\_\-nodes = 0}}\label{indexdb_8cpp_af5e8f9da4a6e4528def30530c2439206}
\hypertarget{indexdb_8cpp_ab3f078684998b83967d507d0f453f454}{\index{indexdb.\-cpp@{indexdb.\-cpp}!verbose@{verbose}}
\index{verbose@{verbose}!indexdb.cpp@{indexdb.\-cpp}}
\subsubsection[{verbose}]{\setlength{\rightskip}{0pt plus 5cm}bool verbose = false}}\label{indexdb_8cpp_ab3f078684998b83967d507d0f453f454}
