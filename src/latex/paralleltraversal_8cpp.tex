\hypertarget{paralleltraversal_8cpp}{\section{paralleltraversal.\-cpp File Reference}
\label{paralleltraversal_8cpp}\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}}
}
{\ttfamily \#include \char`\"{}../include/paralleltraversal.\-hpp\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../include/ssw.\-h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../alp/sls\-\_\-alp\-\_\-data.\-hpp\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../alp/sls\-\_\-alp\-\_\-sim.\-hpp\char`\"{}}\\*
{\ttfamily \#include \char`\"{}../alp/gumbel\-\_\-params.\-hpp\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{paralleltraversal_8cpp_a852c3b510e1152c85991da7f3409b4d3}{E\-N\-T\-R\-Y\-S\-I\-Z\-E}~(2$\ast$sizeof(unsigned int))
\item 
\#define \hyperlink{paralleltraversal_8cpp_a84db90500a1f9527c04e28817d9f60a1}{E\-X\-P}~2.\-71828182845904523536
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{paralleltraversal_8cpp_a30794deb1472194e2edd74e47b3f6a2f}{compare} (mypair const \&a, mypair const \&b)
\item 
bool \hyperlink{paralleltraversal_8cpp_a1f28ab873c1f9f30e5359a263ac7b780}{descending\-\_\-s} (mypair const \&a, mypair const \&b)
\item 
void \hyperlink{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}{traversetrie\-\_\-align} (Node\-Element $\ast$trie\-\_\-t, unsigned int lev\-\_\-t, unsigned char depth, M\-Y\-B\-I\-T\-S\-E\-T $\ast$win\-\_\-k1\-\_\-ptr, M\-Y\-B\-I\-T\-S\-E\-T $\ast$win\-\_\-k1\-\_\-full, bool \&accept\-\_\-zero\-\_\-kmer, vector$<$ id\-\_\-win $>$ \&id\-\_\-hits, int readn, int win\-\_\-num)
\item 
void \hyperlink{paralleltraversal_8cpp_a7184e9ff23e16d0428e13221eaa1705e}{compute\-\_\-gumbel} (long int \-\_\-match, long int \-\_\-mismatch, long int \-\_\-gap\-\_\-open, long int \-\_\-gap\-\_\-extension, string root, string path, unsigned int \&num\-\_\-index\-\_\-parts, char $\ast$acceptedstrings\-\_\-sam, char $\ast$ptr\-\_\-filetype\-\_\-a, char $\ast$$\ast$argv, int argc)
\item 
void \hyperlink{paralleltraversal_8cpp_a2790ed8252fe8ba0732735cce725c4bc}{load\-\_\-ref} (char $\ast$ptr\-\_\-dbfile, char $\ast$buffer, char $\ast$$\ast$reference\-\_\-seq, unsigned int $\ast$reference\-\_\-seq\-\_\-len, unsigned long int seq\-\_\-part\-\_\-size, unsigned long int numseq\-\_\-part, long int start\-\_\-part, bool load\-\_\-for\-\_\-search)
\item 
void \hyperlink{paralleltraversal_8cpp_a5be67e3f479b18a9976e0e8ed5e3ce32}{load\-\_\-index} (string \&root, string \&path, string part\-\_\-str, long int $\ast$start\-\_\-part, long int $\ast$seq\-\_\-part\-\_\-size, unsigned int $\ast$numseq\-\_\-part, kmer $\ast$\&lookup\-\_\-tbl, kmer\-\_\-origin $\ast$\&positions\-\_\-tbl, unsigned int \&number\-\_\-elements)
\item 
void \hyperlink{paralleltraversal_8cpp_ae10071d85a50b60e3da9a5182dde4b39}{find\-\_\-lis} (deque$<$ mypair $>$ \&a, vector$<$ int $>$ \&b, int readn)
\item 
void \hyperlink{paralleltraversal_8cpp_a9eac9d55bcfaa96dd7fbdf1eac0575d0}{paralleltraversal} (char $\ast$inputreads, char $\ast$ptr\-\_\-filetype\-\_\-ar, char $\ast$ptr\-\_\-filetype\-\_\-or, char $\ast$ptr\-\_\-dbfile, long int match, long int mismatch, long int gap\-\_\-open, long int gap\-\_\-extension, string \&root, string \&path, int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
double \hyperlink{paralleltraversal_8cpp_a8447db76b0717fd47ccc36b5ddb79bef}{entropy\-\_\-\-H\-\_\-gv} = 0.\-0
\item 
long long \hyperlink{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{expect\-\_\-\-L\-\_\-gv} = 0
\item 
double \hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\-\_\-gv} = -\/1.\-0
\item 
double \hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\-\_\-gv} = -\/1.\-0
\item 
double \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\-\_\-freq\-\_\-gv} \mbox{[}4\mbox{]} = \{0\}
\item 
int \hyperlink{paralleltraversal_8cpp_a322857d371001fcdc993be8b69d49d01}{minimal\-\_\-score\-\_\-gv} = 0
\item 
int \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\-\_\-gv} = -\/1
\item 
int \hyperlink{paralleltraversal_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\-\_\-gv} = -\/1
\item 
int \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\-\_\-gv} = -\/1
\item 
size\-\_\-t \hyperlink{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}{numseq\-\_\-gv} = 0
\item 
unsigned int \hyperlink{paralleltraversal_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} = 0
\item 
int \hyperlink{paralleltraversal_8cpp_a192f0b0d3603008657d8cee829933644}{total\-\_\-read\-\_\-gv} = 0
\item 
long long \hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\-\_\-ref\-\_\-gv} = 0
\item 
long long \hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\-\_\-read\-\_\-gv} = 0
\item 
long long \hyperlink{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}{number\-\_\-total\-\_\-read\-\_\-gv} = 0
\item 
int \hyperlink{paralleltraversal_8cpp_ab9275c2d178b44582254272d1bc88b34}{numbvs\-\_\-gv} = 0
\item 
int \hyperlink{paralleltraversal_8cpp_a2582d8e7e72b78283ba60394bbe9adb4}{leaf} = 0
\item 
set$<$ unsigned int $>$\-::iterator \hyperlink{paralleltraversal_8cpp_a6ef7f11ffe917af62a9e613446b4957a}{id\-\_\-it}
\item 
unsigned int \hyperlink{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{table} \mbox{[}4\mbox{]}\mbox{[}16\mbox{]}\mbox{[}14\mbox{]}
\item 
char \hyperlink{paralleltraversal_8cpp_adf8e093429055846312e4c3c3d564c1f}{complement} \mbox{[}4\mbox{]} = \{3,2,1,0\}
\item 
char \hyperlink{paralleltraversal_8cpp_ae3449226a5476670d1618cda4c098202}{to\-\_\-char} \mbox{[}4\mbox{]} = \{'A','C','G','T'\}
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\hypertarget{paralleltraversal_8cpp_a852c3b510e1152c85991da7f3409b4d3}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!E\-N\-T\-R\-Y\-S\-I\-Z\-E@{E\-N\-T\-R\-Y\-S\-I\-Z\-E}}
\index{E\-N\-T\-R\-Y\-S\-I\-Z\-E@{E\-N\-T\-R\-Y\-S\-I\-Z\-E}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{E\-N\-T\-R\-Y\-S\-I\-Z\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define E\-N\-T\-R\-Y\-S\-I\-Z\-E~(2$\ast$sizeof(unsigned int))}}\label{paralleltraversal_8cpp_a852c3b510e1152c85991da7f3409b4d3}
The following

The following three .hpp files are for computing the Gumbel parameters using the A\-L\-P program \hypertarget{paralleltraversal_8cpp_a84db90500a1f9527c04e28817d9f60a1}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!E\-X\-P@{E\-X\-P}}
\index{E\-X\-P@{E\-X\-P}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{E\-X\-P}]{\setlength{\rightskip}{0pt plus 5cm}\#define E\-X\-P~2.\-71828182845904523536}}\label{paralleltraversal_8cpp_a84db90500a1f9527c04e28817d9f60a1}


\subsection{Function Documentation}
\hypertarget{paralleltraversal_8cpp_a30794deb1472194e2edd74e47b3f6a2f}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!compare@{compare}}
\index{compare@{compare}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{compare}]{\setlength{\rightskip}{0pt plus 5cm}bool compare (
\begin{DoxyParamCaption}
\item[{mypair const \&}]{a, }
\item[{mypair const \&}]{b}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a30794deb1472194e2edd74e47b3f6a2f}

\begin{DoxyCode}
125 \{
126     \textcolor{keywordflow}{return} (a.first < b.first); 
127 \}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a7184e9ff23e16d0428e13221eaa1705e}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!compute\-\_\-gumbel@{compute\-\_\-gumbel}}
\index{compute\-\_\-gumbel@{compute\-\_\-gumbel}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{compute\-\_\-gumbel}]{\setlength{\rightskip}{0pt plus 5cm}void compute\-\_\-gumbel (
\begin{DoxyParamCaption}
\item[{long int}]{\-\_\-match, }
\item[{long int}]{\-\_\-mismatch, }
\item[{long int}]{\-\_\-gap\-\_\-open, }
\item[{long int}]{\-\_\-gap\-\_\-extension, }
\item[{string}]{root, }
\item[{string}]{path, }
\item[{unsigned int \&}]{num\-\_\-index\-\_\-parts, }
\item[{char $\ast$}]{acceptedstrings\-\_\-sam, }
\item[{char $\ast$}]{ptr\-\_\-filetype\-\_\-a, }
\item[{char $\ast$$\ast$}]{argv, }
\item[{int}]{argc}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a7184e9ff23e16d0428e13221eaa1705e}

\begin{DoxyCode}
364 \{
365 
366     ifstream stats( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".stats"}).c\_str(), ios::in | ios::binary );
367 
368     \textcolor{comment}{/* SQ header for reference sequences (since in sortmedna, they are only loaded by section) */}
369 
370     \textcolor{comment}{/* number of sequences in the reference file */}
371     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num\_sq = 0;
372     stats.read(reinterpret\_cast<char*>(&num\_sq), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
373 
374     FILE *outfile = NULL;
375     \textcolor{keywordflow}{if} ( ptr\_filetype\_a && \hyperlink{main_8cpp_a2cd647a5df32ab9cad67cb8a452d7aec}{samout\_gv} )
376     \{
377             outfile = fopen (acceptedstrings\_sam,\textcolor{stringliteral}{"a"});
378             \textcolor{keywordflow}{if} ( outfile == NULL )
379             \{
380                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not open SAM output file to add @SQ in header\(\backslash\)n"});
381                 exit(EXIT\_FAILURE);
382             \}
383             \textcolor{keywordflow}{else}
384             \{
385                 \textcolor{comment}{/* @HD header */}
386                 fprintf(outfile, \textcolor{stringliteral}{"@HD\(\backslash\)tVN:1.0\(\backslash\)tSO:unsorted\(\backslash\)n"});
387             \}
388     \}
389 
390     \textcolor{comment}{/* loop through each @SQ */}
391     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} j = 0; j < num\_sq; j++ )
392     \{
393         \textcolor{comment}{/* length of the sequence id */}
394         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len\_id = 0;
395         stats.read(reinterpret\_cast<char*>(&len\_id), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
396 
397         \textcolor{comment}{/* the sequence id string */}
398         \textcolor{keywordtype}{char} s[len\_id+1];
399         memset(s,0,len\_id+1);
400         stats.read(reinterpret\_cast<char*>(&s), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char})*len\_id);
401 
402         \textcolor{comment}{/* the length of the sequence itself */}
403         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} len\_seq = 0;
404         stats.read(reinterpret\_cast<char*>(&len\_seq), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
405 
406         \textcolor{keywordflow}{if} ( outfile )
407         \{
408             \textcolor{comment}{/* @SQ header */}
409             fprintf(outfile,\textcolor{stringliteral}{"@SQ\(\backslash\)tSN:%s\(\backslash\)tLN:%u\(\backslash\)n"},s,len\_seq);
410         \}
411     \}
412 
413     \textcolor{keywordflow}{if} ( outfile )
414     \{
415         \textcolor{comment}{/* @PG to sam file */}
416         fprintf(outfile, \textcolor{stringliteral}{"@PG\(\backslash\)tID:sortmedna\(\backslash\)tVN:1.0\(\backslash\)tCL:"});
417         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < argc; j++ )
418             fprintf(outfile,\textcolor{stringliteral}{"%s "},argv[j]);
419         fprintf(outfile,\textcolor{stringliteral}{"\(\backslash\)n"});
420 
421         fclose(outfile);
422     \}
423 
424     \textcolor{comment}{/* read the A/C/G/T distribution frequencies */}
425     stats.read(reinterpret\_cast<char*>(&\hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{double})*4);
426 
427     \textcolor{comment}{/* read the size of the reference database */}
428     stats.read(reinterpret\_cast<char*>(&\hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{long}));
429 
430     \textcolor{comment}{/* read the sliding window length lnwin\_gv & initialize */}
431     stats.read(reinterpret\_cast<char*>(&\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
432 
433     \textcolor{comment}{/* total number of reference sequences in all index parts combined */}
434     stats.read(reinterpret\_cast<char*>(&\hyperlink{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}{numseq\_gv}), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{int}));
435 
436     \textcolor{comment}{/* number of index parts */}
437     stats.read(reinterpret\_cast<char*>(&num\_index\_parts), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
438 
439     \hyperlink{paralleltraversal_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{pread\_gv} = \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}+1;
440     \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv} = \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}/2;
441 
442     \textcolor{comment}{/* set the window shift for different seed lengths (if not set by user, or one of the lengths is <= 0) 
      */}
443     \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1} <= 0 || \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2} <= 0 || 
      \hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3} <= 0 )
444     \{
445         \hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1} = \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv};
446         \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2} = \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv};
447         \hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3} = 3;
448     \}
449 
450     \hyperlink{paralleltraversal_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{mask32} = (1<<\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv})-1;
451 
452     \textcolor{comment}{/* number of bitvectors at depth > 0 in [w\_1] reverse or [w\_2] forward */}
453     \hyperlink{paralleltraversal_8cpp_ab9275c2d178b44582254272d1bc88b34}{numbvs\_gv} = (int)4*(\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-3);
454 
455     stats.close();
456 
457 
458 
459 
460   \textcolor{comment}{/* compute Gumbel parameters */}
461     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} rand\_ = 182345345;
462     \textcolor{keywordtype}{string} randout\_= path + \textcolor{stringliteral}{"/alp/random\_param.txt"};
463 
464     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapopen\_ = \_gap\_open;
465     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapopen1\_ = \_gap\_open;
466     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapopen2\_ = \_gap\_open;
467 
468     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapextend\_ = \_gap\_extension;
469     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapextend1\_ = \_gap\_extension;
470     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} gapextend2\_ = \_gap\_extension;
471 
472     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} match = \_match;
473     \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} mismatch = \_mismatch;
474     \textcolor{keywordtype}{double} A\_ = \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[0];
475     \textcolor{keywordtype}{double} C\_ = \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[1];
476     \textcolor{keywordtype}{double} G\_ = \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[2];
477     \textcolor{keywordtype}{double} T\_ = \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[3];
478 
479     \textcolor{keywordtype}{string} scoremat\_file\_name\_ =\textcolor{stringliteral}{""};
480     \textcolor{keywordtype}{string} freqs1\_file\_name\_ =\textcolor{stringliteral}{""};
481     \textcolor{keywordtype}{string} freqs2\_file\_name\_ =\textcolor{stringliteral}{""};
482     \textcolor{keywordtype}{double} max\_time\_=1;
483     \textcolor{keywordtype}{double} max\_mem\_=500;
484     \textcolor{keywordtype}{double} eps\_lambda\_gv\_=0.001;
485     \textcolor{keywordtype}{double} eps\_K\_gv\_=0.005;
486     \textcolor{keywordtype}{string} gumbelparout\_file\_name\_ =\textcolor{stringliteral}{""};
487     \textcolor{keywordtype}{bool} gapped\_ = \textcolor{keyword}{true};
488     \textcolor{keywordtype}{bool} insertions\_after\_deletions\_=\textcolor{keyword}{false};
489 
490     Sls::set\_of\_parameters gumbel\_params;
491 
492 
493     CGumbelParamsCalc::Params\_Run2(
494             rand\_,\textcolor{comment}{//randomization number}
495             randout\_,\textcolor{comment}{//if true, then the program outputs complete randomization information into a file}
496 
497             gapopen\_,\textcolor{comment}{//gap opening penalty}
498             gapopen1\_,\textcolor{comment}{//gap opening penalty for a gap in the sequence #1}
499             gapopen2\_,\textcolor{comment}{//gap opening penalty for a gap in the sequence #2}
500 
501             gapextend\_,\textcolor{comment}{//gap extension penalty}
502             gapextend1\_,\textcolor{comment}{//gap extension penalty for a gap in the sequence #1}
503             gapextend2\_,\textcolor{comment}{//gap extension penalty for a gap in the sequence #2}
504 
505             scoremat\_file\_name\_,\textcolor{comment}{//scoring matrix file name}
506             freqs1\_file\_name\_,\textcolor{comment}{//probabilities1 file name}
507             freqs2\_file\_name\_,\textcolor{comment}{//probabilities1 file name}
508             max\_time\_,\textcolor{comment}{//maximum allowed calculation time in seconds}
509             max\_mem\_,\textcolor{comment}{//maximum allowed memory usage in MB}
510             eps\_lambda\_gv\_,\textcolor{comment}{//relative error for lambda\_gv calculation}
511             eps\_K\_gv\_,\textcolor{comment}{//relative error for K\_gv calculation}
512             gumbelparout\_file\_name\_,
513             gapped\_,
514             insertions\_after\_deletions\_,\textcolor{comment}{//if true, then insertions after deletions are allowed}
515             gumbel\_params,
516             match,\textcolor{comment}{//NEW - SW score for a match,}
517             mismatch,\textcolor{comment}{//NEW - SW score for a mismatch,}
518         A\_,\textcolor{comment}{//NEW - background frequency for A}
519             C\_,\textcolor{comment}{//NEW - background frequency for C}
520             G\_,\textcolor{comment}{//NEW - background frequency for G}
521             T\_,\textcolor{comment}{//NEW- background frequency for T}
522             \hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\_gv},
523             \hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}
524             );   
525 
526 
527     \textcolor{comment}{/* compute the entropy H */}
528     \hyperlink{paralleltraversal_8cpp_a8447db76b0717fd47ccc36b5ddb79bef}{entropy\_H\_gv} = -(\hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[0]*(log(
      \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[0])/log(2)) + 
529                                 \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[1]*(log(
      \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[1])/log(2)) + 
530                                 \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[2]*(log(
      \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[2])/log(2)) + 
531                                 \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[3]*(log(
      \hyperlink{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{background\_freq\_gv}[3])/log(2)));
532 
533     \textcolor{comment}{/* compute expected HSP length */}
534     \hyperlink{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{expect\_L\_gv} = log(\hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}*\hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv}*\hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv})/
      \hyperlink{paralleltraversal_8cpp_a8447db76b0717fd47ccc36b5ddb79bef}{entropy\_H\_gv};
535 
536     \textcolor{comment}{/* correct the reads & databases sizes for e-value calculation */}
537     \textcolor{keywordflow}{if} ( \hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv} > (\hyperlink{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{expect\_L\_gv}*\hyperlink{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}{numseq\_gv}) )
538         \hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv}-=(\hyperlink{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{expect\_L\_gv}*\hyperlink{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}{numseq\_gv});
539     \hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv}-=(\hyperlink{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{expect\_L\_gv}*\hyperlink{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}{number\_total\_read\_gv});
540 
541     \textcolor{comment}{/* minimum score required to reach E-value */}
542     \hyperlink{paralleltraversal_8cpp_a322857d371001fcdc993be8b69d49d01}{minimal\_score\_gv} = (log(\hyperlink{main_8cpp_a3a53c9e3df0ddd5dd1a79602797be690}{evalue}/((\textcolor{keywordtype}{double})\hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}*
      \hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv}*\hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv})))/-\hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\_gv};
543         
544     return ;
545 
546 \}\textcolor{comment}{//compute\_gumbel}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a1f28ab873c1f9f30e5359a263ac7b780}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!descending\-\_\-s@{descending\-\_\-s}}
\index{descending\-\_\-s@{descending\-\_\-s}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{descending\-\_\-s}]{\setlength{\rightskip}{0pt plus 5cm}bool descending\-\_\-s (
\begin{DoxyParamCaption}
\item[{mypair const \&}]{a, }
\item[{mypair const \&}]{b}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a1f28ab873c1f9f30e5359a263ac7b780}

\begin{DoxyCode}
131 \{
132     \textcolor{keywordflow}{return} (a.first > b.first); 
133 \}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_ae10071d85a50b60e3da9a5182dde4b39}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!find\-\_\-lis@{find\-\_\-lis}}
\index{find\-\_\-lis@{find\-\_\-lis}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{find\-\_\-lis}]{\setlength{\rightskip}{0pt plus 5cm}void find\-\_\-lis (
\begin{DoxyParamCaption}
\item[{deque$<$ mypair $>$ \&}]{a, }
\item[{vector$<$ int $>$ \&}]{b, }
\item[{int}]{readn}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_ae10071d85a50b60e3da9a5182dde4b39}

\begin{DoxyCode}
914 \{
915     vector<int> p(a.size());
916     \textcolor{keywordtype}{int} u, v;
917  
918     \textcolor{keywordflow}{if} (a.empty()) \textcolor{keywordflow}{return};
919  
920     b.push\_back(0);
921  
922     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < a.size(); i++) 
923     \{
924     \textcolor{comment}{// If next element a[i] is greater than last element of current longest subsequence a[b.back()], just
       push it at back of "b" and continue}
925         \textcolor{keywordflow}{if} (a[b.back()].second < a[i].second)
926         \{
927             p[i] = b.back();
928             b.push\_back(i);
929             \textcolor{keywordflow}{continue};
930         \}
931  
932         \textcolor{comment}{// Binary search to find the smallest element referenced by b which is just bigger than a[i]}
933         \textcolor{comment}{// Note : Binary search is performed on b (and not a). Size of b is always <=k and hence
       contributes O(log k) to complexity.    }
934         \textcolor{keywordflow}{for} (u = 0, v = b.size()-1; u < v;) 
935         \{
936             \textcolor{keywordtype}{int} c = (u + v) / 2;
937             \textcolor{keywordflow}{if} ( a[b[c]].second < a[i].second )
938                 u=c+1; 
939             \textcolor{keywordflow}{else} 
940                 v=c;
941         \}
942 
943         \textcolor{comment}{// Update b if new value is smaller then previously referenced value }
944         \textcolor{keywordflow}{if} (a[i].second < a[b[u]].second) 
945         \{
946                 \textcolor{keywordflow}{if} (u > 0) p[i] = b[u-1];
947                 b[u] = i;
948         \}
949     \}
950 
951  
952     \textcolor{keywordflow}{for} (u = b.size(), v = b.back(); u--; v = p[v]) b[u] = v;
953 \}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a5be67e3f479b18a9976e0e8ed5e3ce32}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!load\-\_\-index@{load\-\_\-index}}
\index{load\-\_\-index@{load\-\_\-index}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{load\-\_\-index}]{\setlength{\rightskip}{0pt plus 5cm}void load\-\_\-index (
\begin{DoxyParamCaption}
\item[{string \&}]{root, }
\item[{string \&}]{path, }
\item[{string}]{part\-\_\-str, }
\item[{long int $\ast$}]{start\-\_\-part, }
\item[{long int $\ast$}]{seq\-\_\-part\-\_\-size, }
\item[{unsigned int $\ast$}]{numseq\-\_\-part, }
\item[{kmer $\ast$\&}]{lookup\-\_\-tbl, }
\item[{kmer\-\_\-origin $\ast$\&}]{positions\-\_\-tbl, }
\item[{unsigned int \&}]{number\-\_\-elements}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a5be67e3f479b18a9976e0e8ed5e3ce32}

\begin{DoxyCode}
642 \{
643 
644 
645     \textcolor{comment}{/* STEP 1: load the kmer 'count' variables (dbname.kmer.dat) */}
646     ifstream inkmer( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".kmer\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str(), ios::in | 
      ios::binary );
647 
648     \textcolor{keywordflow}{if} ( !inkmer.good() )
649     \{
650         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: The index '%s' does not exist.\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{"
      .kmer\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str());
651         fprintf(stderr,\textcolor{stringliteral}{"  Make sure you have constructed your index using the command `indexdb'. See
       `indexdb -h' for help.\(\backslash\)n\(\backslash\)n"});
652         exit(EXIT\_FAILURE);
653     \}
654 
655     \textcolor{comment}{/* where the section starts in the file */}
656     inkmer.read(reinterpret\_cast<char*>(start\_part), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int}));
657 
658     \textcolor{comment}{/* number of bytes of reference sequences to read */}
659     inkmer.read(reinterpret\_cast<char*>(seq\_part\_size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{long} \textcolor{keywordtype}{int}));
660 
661     \textcolor{comment}{/* the number of sequences in this part */}
662     inkmer.read(reinterpret\_cast<char*>(numseq\_part), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
663 
664     lookup\_tbl = \textcolor{keyword}{new} kmer[(1<<\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv})]();
665     \textcolor{keywordflow}{if} ( lookup\_tbl == NULL )
666     \{
667         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: failed to allocate memory for look-up table (paralleltraversal.cpp)\(\backslash\)n\(\backslash\)n"}
      );
668         exit(EXIT\_FAILURE);
669     \}
670 
671     \textcolor{keywordtype}{int} limit = 1<<\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv};
672 
673     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < limit; i++ )
674         inkmer.read(reinterpret\_cast<char*>(&(lookup\_tbl[i].count)), UINT);
675 
676     inkmer.close();
677 
678 
679     \textcolor{comment}{/* STEP 2: load the burst tries ( bursttrief.dat, bursttrier.dat ) */}
680     ifstream btrie( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".bursttrie\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str(), ios::in |
       ios::binary );
681 
682     \textcolor{keywordflow}{if} ( !btrie.good() )
683     \{
684         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: The index '%s' does not exist.\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{"
      .bursttrie\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str());
685         fprintf(stderr,\textcolor{stringliteral}{"  Make sure you have constructed your index using the command `indexdb'. See
       `indexdb -h' for help.\(\backslash\)n\(\backslash\)n"});
686         exit(EXIT\_FAILURE);
687     \}
688 
689 
690     \textcolor{comment}{/* loop through all 9-mers */}
691     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (1<<\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}); i++ )
692     \{
693         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sizeoftries[2] = \{0\};
694         \textcolor{comment}{/* ptr to block of memory for two mini-burst tries */}
695         \textcolor{keywordtype}{char} *dst = NULL;
696 
697         \textcolor{comment}{/* the size of both mini-burst tries */}
698         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < 2; j++ )
699         \{
700             btrie.read(reinterpret\_cast<char*>(&sizeoftries[j]), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
701         \}
702 
703         \textcolor{comment}{/* allocate contiguous memory for both mini-burst tries if they exist */}
704         \textcolor{keywordflow}{if} ( lookup\_tbl[i].count != 0 )
705         \{
706             dst = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[(sizeoftries[0]+sizeoftries[1])]();
707             \textcolor{keywordflow}{if} ( dst == NULL )
708             \{
709                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: failed to allocate memory for mini-burst tries
       (paralleltraversal.cpp)\(\backslash\)n"});
710                 exit(EXIT\_FAILURE);
711             \}
712 
713             \textcolor{comment}{/* load 2 burst tries per 9-mer */}
714             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < 2; j++ )   
715             \{
716                 \textcolor{comment}{/* mini-burst trie exists */}
717                 \textcolor{keywordflow}{if} ( sizeoftries[j] != 0 )
718                 \{
719                     \textcolor{comment}{/* create a root trie node */}
720                     NodeElement newnode[4];
721 
722                     \textcolor{comment}{/* copy the root trie node into the beginning of burst trie array */}
723                     memcpy( dst, &newnode[0], \textcolor{keyword}{sizeof}(NodeElement)*4);
724                     memset( dst, 0, \textcolor{keyword}{sizeof}(NodeElement)*4);
725 
726                     \textcolor{keywordflow}{if} ( j == 0 )
727                         lookup\_tbl[i].trie\_F = (NodeElement*)dst;
728                     \textcolor{keywordflow}{else}
729                         lookup\_tbl[i].trie\_R = (NodeElement*)dst;
730 
731                     \textcolor{comment}{/* queue to store the trie nodes as we create them */}
732                     deque<NodeElement*> nodes;
733                     nodes.push\_back( (NodeElement*)dst );
734                     ((NodeElement *&) dst)+=4;
735 
736                     \textcolor{comment}{/* queue to store the flags of node elements given in the binary file */}
737                     deque<unsigned char> flags;
738 
739                     \textcolor{comment}{/* read the first trie node */}
740                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
741                     \{
742                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} tmp;
743                         btrie.read(reinterpret\_cast<char*>(&tmp), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));   
744                         flags.push\_back(tmp);
745                     \}
746 
747                     \textcolor{comment}{/* build the mini-burst trie */}
748                     \textcolor{keywordflow}{while} ( !nodes.empty() )
749                     \{
750                         \textcolor{comment}{/* ptr to traverse each trie node */}
751                         NodeElement* node = nodes.front();
752 
753                         \textcolor{comment}{/* trie node elements */}
754                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
755                         \{
756                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} flag = flags.front();
757 
758                             \textcolor{comment}{/* what does the node element point to */}
759                             \textcolor{keywordflow}{switch}( flag )
760                             \{
761                                 \textcolor{comment}{/* set values to 0 */}
762                                 \textcolor{keywordflow}{case} 0: 
763                                 \{
764                                     node->flag = 0;
765                                     node->size = 0;
766                                     node->whichnode.trie = NULL;
767                                 \}
768                                     \textcolor{keywordflow}{break};
769                                 \textcolor{comment}{/* trie node */}
770                                 \textcolor{keywordflow}{case} 1:
771                                 \{
772                                     \textcolor{comment}{/* read the trie node */}
773                                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < 4; i++ )
774                                     \{
775                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} tmp;
776                                         btrie.read(reinterpret\_cast<char*>(&tmp), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}));   
777                                         flags.push\_back(tmp);
778                                     \}
779 
780                                     node->flag = 1;
781                                     node->size = 0;
782                                     NodeElement newnode[4];
783                                     memcpy( (NodeElement*)dst, &newnode[0], \textcolor{keyword}{sizeof}(NodeElement)*4);
784                                     nodes.push\_back( (NodeElement*)dst );
785                                     node->whichnode.trie = (NodeElement*)dst;
786                                     ((NodeElement *&) dst)+=4;
787 
788                                 \}
789                                     \textcolor{keywordflow}{break};
790                                 \textcolor{comment}{/* bucket */}
791                                 \textcolor{keywordflow}{case} 2:
792                                 \{
793                                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sizeofbucket = 0;
794 
795                                     \textcolor{comment}{/* read the bucket info */}
796                                     btrie.read(reinterpret\_cast<char*>(&sizeofbucket), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})
      );
797                                     \textcolor{keywordtype}{char}* bucket = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[sizeofbucket]();
798                                     \textcolor{keywordflow}{if} ( bucket == NULL )
799                                     \{
800                                         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: failed to allocate memory for allocate
       bucket (paralleltraversal.cpp)\(\backslash\)n"});
801                                         exit(EXIT\_FAILURE);
802                                     \}
803 
804                                     btrie.read(reinterpret\_cast<char*>(bucket), sizeofbucket);
805                     
806                                     \textcolor{comment}{/* copy the bucket into the burst trie array */}
807                                     memcpy( (\textcolor{keywordtype}{void}*)dst, (\textcolor{keywordtype}{void}*)bucket, sizeofbucket);       
808     
809                                     \textcolor{keyword}{delete} [] bucket;
810                                     bucket = NULL;
811 
812                                     \textcolor{comment}{/* assign pointers from trie node to the bucket */}
813                                     node->flag = flag;
814                                     node->whichnode.bucket = dst;
815                                     node->size = sizeofbucket;
816                                     dst = ((\textcolor{keywordtype}{char} *)dst)+sizeofbucket;
817                                     
818                                 \}
819                                     \textcolor{keywordflow}{break};
820                                 \textcolor{comment}{/* ? */}
821                                 \textcolor{keywordflow}{default}: ;
822                                     \textcolor{keywordflow}{break};
823                             \} 
824 
825                             flags.pop\_front();
826                             node++;
827 
828                         \}\textcolor{comment}{//~loop through 4 node elements in a trie node}
829 
830                         nodes.pop\_front();
831             
832                     \}\textcolor{comment}{//~while !nodes.empty()}
833                 \}\textcolor{comment}{//~if mini-burst trie exists}
834                 \textcolor{keywordflow}{else}
835                 \{
836                     \textcolor{keywordflow}{if} ( j == 0 )
837                         lookup\_tbl[i].trie\_F = NULL;
838                     \textcolor{keywordflow}{else}
839                         lookup\_tbl[i].trie\_R = NULL;
840                 \}
841             \}\textcolor{comment}{//~for both mini-burst tries}
842         \}\textcolor{comment}{//~if ( sizeoftries != 0 )}
843         \textcolor{keywordflow}{else}
844         \{
845             lookup\_tbl[i].trie\_F = NULL;
846             lookup\_tbl[i].trie\_R = NULL;
847         \}
848     \}\textcolor{comment}{//~for all 9-mers in the look-up table}
849 
850     btrie.close();
851 
852 
853     \textcolor{comment}{/* STEP 3: load the position reference tables (pos.dat) */}
854     ifstream inreff( (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + root + \textcolor{stringliteral}{".pos\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str(), ios::in | 
      ios::binary );
855 
856     \textcolor{keywordflow}{if} ( !inreff.good() )
857     \{
858         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: The database name '%s' does not exist.\(\backslash\)n\(\backslash\)n"}, (\textcolor{keywordtype}{char}*)(path + \textcolor{stringliteral}{"/index/"} + 
      root + \textcolor{stringliteral}{".pos\_"} + part\_str + \textcolor{stringliteral}{".dat"}).c\_str());
859         exit(EXIT\_FAILURE);
860     \}
861 
862     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} size = 0;  
863 
864     inreff.read(reinterpret\_cast<char*>(&number\_elements), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
865 
866     positions\_tbl = \textcolor{keyword}{new} kmer\_origin[number\_elements]();
867     \textcolor{keywordflow}{if} ( positions\_tbl == NULL )
868     \{
869         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for positions\_tbl (main(),
       paralleltraversal.cpp)\(\backslash\)n"});
870         exit(EXIT\_FAILURE);
871     \}
872 
873 
874     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < number\_elements; i++ )
875     \{
876         \textcolor{comment}{/* the number of positions */}
877         inreff.read(reinterpret\_cast<char*>(&size), \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}));
878         positions\_tbl[i].size = size;
879 
880         \textcolor{comment}{/* the sequence seq\_pos array */}
881         positions\_tbl[i].arr = \textcolor{keyword}{new} seq\_pos[size]();
882 
883         \textcolor{keywordflow}{if} ( positions\_tbl[i].arr == NULL )
884         \{
885             fprintf(stderr, \textcolor{stringliteral}{"  ERROR: could not allocate memory for positions\_tbl (paralleltraversal.cpp)\(\backslash\)n
      "});  
886             exit(EXIT\_FAILURE);
887         \}
888 
889         inreff.read(reinterpret\_cast<char*>(positions\_tbl[i].arr), \textcolor{keyword}{sizeof}(seq\_pos)*size);
890     \}
891 
892     inreff.close();
893 
894     return ;
895 
896 \}\textcolor{comment}{//~load\_index()}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a2790ed8252fe8ba0732735cce725c4bc}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!load\-\_\-ref@{load\-\_\-ref}}
\index{load\-\_\-ref@{load\-\_\-ref}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{load\-\_\-ref}]{\setlength{\rightskip}{0pt plus 5cm}void load\-\_\-ref (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{ptr\-\_\-dbfile, }
\item[{char $\ast$}]{buffer, }
\item[{char $\ast$$\ast$}]{reference\-\_\-seq, }
\item[{unsigned int $\ast$}]{reference\-\_\-seq\-\_\-len, }
\item[{unsigned long int}]{seq\-\_\-part\-\_\-size, }
\item[{unsigned long int}]{numseq\-\_\-part, }
\item[{long int}]{start\-\_\-part, }
\item[{bool}]{load\-\_\-for\-\_\-search}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a2790ed8252fe8ba0732735cce725c4bc}

\begin{DoxyCode}
568 \{
569     FILE *fp = fopen(ptr\_dbfile,\textcolor{stringliteral}{"r"});
570     \textcolor{keywordflow}{if} ( fp == NULL )
571     \{
572         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not open file %s\(\backslash\)n"},ptr\_dbfile);
573         exit(EXIT\_FAILURE);
574     \}
575 
576     \textcolor{comment}{/* set the file pointer to the first sequence added to the index for this index file section */}
577     fseek(fp,start\_part,SEEK\_SET);
578 
579     \textcolor{comment}{/* load references sequences into memory, skipping the new lines & spaces in the fasta format */}
580     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} num\_seq\_read = 0;
581     \textcolor{keywordtype}{char} *s = buffer;
582 
583     \textcolor{keywordtype}{int} i = 0;
584     \textcolor{keywordtype}{int} j = 0;
585     \textcolor{keywordtype}{char} c = fgetc(fp);
586     \textcolor{keywordflow}{do}
587     \{
588         \textcolor{comment}{/* the tag */}
589         reference\_seq[i++] = s;
590         \textcolor{keywordflow}{while} ( c != \textcolor{charliteral}{'\(\backslash\)n'} ) \{ *s++ = c; c = fgetc(fp); \}
591         \textcolor{comment}{/* new line*/}
592         *s++ = c;
593         
594         \textcolor{comment}{/* the sequence */}
595         reference\_seq[i++] = s;
596         c = fgetc(fp);
597         \textcolor{keywordflow}{while} ( (c != \textcolor{charliteral}{'>'}) && (c != EOF) )
598         \{
599             \textcolor{keywordflow}{if} ( c != \textcolor{charliteral}{'\(\backslash\)n'} && c != \textcolor{charliteral}{' '} )
600             \{
601                 *s++ = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[(int)c];
602                 \textcolor{comment}{/* record the sequence length as we read it */}
603                 \textcolor{keywordflow}{if} ( load\_for\_search )
604                     reference\_seq\_len[j]++;
605             \}
606             c = fgetc(fp);
607         \}
608 
609         *s++ = \textcolor{charliteral}{'\(\backslash\)n'};
610         j++;
611 
612         num\_seq\_read++;
613 
614     \} \textcolor{keywordflow}{while} ( (num\_seq\_read != numseq\_part) && (c != EOF) );
615 
616     *(s-1) = \textcolor{charliteral}{'\(\backslash\)0'};
617 
618     fclose(fp);
619 \}\textcolor{comment}{//~load\_ref}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a9eac9d55bcfaa96dd7fbdf1eac0575d0}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!paralleltraversal@{paralleltraversal}}
\index{paralleltraversal@{paralleltraversal}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{paralleltraversal}]{\setlength{\rightskip}{0pt plus 5cm}void paralleltraversal (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{inputreads, }
\item[{char $\ast$}]{ptr\-\_\-filetype\-\_\-ar, }
\item[{char $\ast$}]{ptr\-\_\-filetype\-\_\-or, }
\item[{char $\ast$}]{ptr\-\_\-dbfile, }
\item[{long int}]{match, }
\item[{long int}]{mismatch, }
\item[{long int}]{gap\-\_\-open, }
\item[{long int}]{gap\-\_\-extension, }
\item[{string \&}]{root, }
\item[{string \&}]{path, }
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}\label{paralleltraversal_8cpp_a9eac9d55bcfaa96dd7fbdf1eac0575d0}

\begin{DoxyCode}
990 \{
991 
992     \textcolor{comment}{/* the offset from the start of the reads file for mmap */}
993     off\_t offset = 0;
994     \textcolor{comment}{/* file descriptor to find statistics on the reads file */}
995     \textcolor{keywordtype}{int} fd = -1;
996     \textcolor{comment}{/* the memory map of the reads file */}
997     \textcolor{keywordtype}{char}* raw = NULL;
998     \textcolor{comment}{/* input reads file (fasta or fastq) */}
999     \textcolor{keywordtype}{string} fname   = inputreads;
1000     \textcolor{comment}{/* the size of the full reads file */}
1001     off\_t full\_file\_size = 0;
1002 
1003     \textcolor{comment}{/* for timing different processes */}
1004     \textcolor{keywordtype}{double} s,f;
1005 
1006     \textcolor{comment}{/* the comparing character used in parsing the reads file */}
1007     \textcolor{keywordtype}{char} filesig;
1008 
1009     \textcolor{keywordflow}{if} ((fd = open(fname.c\_str(), O\_RDONLY)) == -1) 
1010     \{
1011         printf(\textcolor{stringliteral}{"  Could not open the reads file!\(\backslash\)n\(\backslash\)n"});
1012         exit(EXIT\_FAILURE);
1013     \}
1014 
1015     \textcolor{comment}{/* check which file format to parse: fasta or fastq */}
1016     \textcolor{keywordtype}{char} c;
1017     ssize\_t rb = -1;
1018 
1019     \textcolor{keywordflow}{if} ((rb = read(fd, &c, 1)) == -1)
1020     \{
1021         printf(\textcolor{stringliteral}{"  Could not read the first character of the reads file!\(\backslash\)n\(\backslash\)n"});
1022         exit(EXIT\_FAILURE);
1023     \}
1024 
1025     \textcolor{comment}{/* set the appropriate settings for the file format */}
1026     \textcolor{keywordflow}{if} ( c == \textcolor{charliteral}{'>'} )
1027     \{
1028         \textcolor{comment}{/* fasta format */}
1029         filesig = \textcolor{charliteral}{'>'};
1030     \}
1031     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( c == \textcolor{charliteral}{'@'} )
1032     \{
1033         \textcolor{comment}{/* fastq format */}
1034         filesig = \textcolor{charliteral}{'@'};
1035     \}
1036     \textcolor{keywordflow}{else}
1037     \{
1038         \textcolor{comment}{/* incorrect format */}
1039         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: The reads file must begin with '>' or '@'\(\backslash\)n\(\backslash\)n"});
1040         exit(EXIT\_FAILURE);
1041     \}
1042 
1043     \textcolor{comment}{/* find the size of the total file */}
1044     \textcolor{keywordflow}{if} ((full\_file\_size = lseek(fd, 0, SEEK\_END)) == -1) 
1045     \{
1046         printf(\textcolor{stringliteral}{"  Could not seek the reads file!\(\backslash\)n\(\backslash\)n"});
1047         exit(EXIT\_FAILURE);
1048     \}
1049     \textcolor{keywordflow}{if} (lseek(fd, 0L, SEEK\_SET) == -1) 
1050     \{
1051         printf(\textcolor{stringliteral}{"  Could not seek set the reads file!\(\backslash\)n\(\backslash\)n"});
1052         exit(EXIT\_FAILURE);
1053     \}
1054 
1055     \textcolor{comment}{/* the size of the sliding window on the full file, ~1GB */}
1056     off\_t partial\_file\_size = full\_file\_size;
1057 
1058     \textcolor{comment}{/* size of the remainder of the file (last window) which is less than pow(2,30) bytes */}
1059     off\_t last\_part\_size = full\_file\_size%\hyperlink{main_8cpp_ade15ad3c0e7a4fb18c3f557d575acf9a}{map\_size\_gv}; 
1060 
1061     \textcolor{comment}{/* number of file sections to mmap */}
1062     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_sections = 0;
1063 
1064     \textcolor{comment}{/* if the full\_file\_size is bigger than m*PAGE\_SIZE, mmap the file by 'windows' of size }
1065 \textcolor{comment}{       partial\_file\_size, otherwise keep the full\_file\_size */}
1066     \textcolor{keywordflow}{if} ( ( file\_sections = ceil( (\textcolor{keywordtype}{double})full\_file\_size/(\textcolor{keywordtype}{double})(\hyperlink{main_8cpp_ade15ad3c0e7a4fb18c3f557d575acf9a}{map\_size\_gv}) ) ) > 1 )
1067            partial\_file\_size = \hyperlink{main_8cpp_ade15ad3c0e7a4fb18c3f557d575acf9a}{map\_size\_gv};
1068 
1069     eprintf( \textcolor{stringliteral}{"\(\backslash\)n  size of reads file: %lu bytes\(\backslash\)n"}, (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int})full\_file\_size );
1070     eprintf( \textcolor{stringliteral}{"  partial section(s) to be executed: %d of size %lu bytes \(\backslash\)n"}, file\_sections,(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{
      int})partial\_file\_size );
1071 
1072     \textcolor{comment}{/* index for file\_sections */}
1073     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} file\_s = 0; 
1074 
1075     \textcolor{comment}{/* pointer to the bridge read (the read which overlaps between two file sections) */}
1076     \textcolor{keywordtype}{char}* bridgeread = NULL; 
1077 
1078     \textcolor{comment}{/* pointer to the position in the bridgeread where to attach the connecting part of read */}
1079     \textcolor{keywordtype}{char}* bridgeptr = NULL;
1080 
1081     \textcolor{comment}{/* the number of new lines covering the start of the bridged read */} 
1082     \textcolor{keywordtype}{int} num\_newlines\_top = 0;
1083 
1084     \textcolor{comment}{/* the number of new lines covering the end of the bridged read */} 
1085     \textcolor{keywordtype}{int} num\_newlines\_bottom = 0;
1086 
1087     \textcolor{comment}{/* for each file section (except the first and the last) we will have two split reads, at the }
1088 \textcolor{comment}{     top and at the bottom. To support paired-reads, we also need to take into account if the}
1089 \textcolor{comment}{     adjacent paired read follows the split read or precedes it. We use the variables offset\_top}
1090 \textcolor{comment}{     and offset\_bottom to signify if the adjacent paired-read of the top and bottom split reads}
1091 \textcolor{comment}{     belong in the current file section or the next. */}
1092 
1093   \textcolor{comment}{/* offset\_top == true if the adjacent paired read follows the split read in the subsequent file section 
      */}
1094     \textcolor{keywordtype}{bool} offset\_top = \textcolor{keyword}{false};
1095     \textcolor{comment}{/* offset\_bottom = true if the adjacent paired read precedes the split read in the current file section
       */}
1096     \textcolor{keywordtype}{bool} offset\_bottom = \textcolor{keyword}{false};
1097 
1098     \textcolor{comment}{/* if output reads are based on matching database */}
1099     ofstream acceptedreads;
1100 
1101 
1102     \textcolor{comment}{/* determine the suffix (fasta,fastq..) of accepted strings */}
1103     \textcolor{keywordtype}{char} suffix[20] = \textcolor{stringliteral}{"out"};
1104     \textcolor{keywordtype}{char} *suff = strrchr( inputreads, \textcolor{charliteral}{'.'});
1105     \textcolor{keywordflow}{if} ( suff != NULL )
1106         strcpy( suffix, suff+1 );
1107     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1108         strcpy( suffix, \textcolor{stringliteral}{"fasta"});
1109     \textcolor{keywordflow}{else}
1110         strcpy( suffix, \textcolor{stringliteral}{"fastq"});
1111     suff = NULL;
1112 
1113     \textcolor{keywordtype}{char} *acceptedstrings = NULL;
1114     \textcolor{keywordtype}{char} *acceptedstrings\_sam = NULL;
1115     \textcolor{keywordtype}{char} *acceptedstrings\_blast = NULL;
1116 
1117     \textcolor{comment}{/* associate the streams with reference sequence names */}
1118     \textcolor{keywordflow}{if} ( ptr\_filetype\_ar != NULL )
1119     \{
1120         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a10e5ea4d5132a75aa2fa4947c714d874}{fastxout\_gv} )
1121         \{
1122             \textcolor{comment}{/* fasta/fastq output */}
1123             acceptedstrings = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[1000]();
1124             \textcolor{keywordflow}{if} ( acceptedstrings == NULL )
1125             \{
1126                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for acceptedstrings
       (paralleltraversal.cpp)\(\backslash\)n"});
1127                 exit(EXIT\_FAILURE);
1128             \}
1129             strcpy ( acceptedstrings, ptr\_filetype\_ar );
1130             strcat ( acceptedstrings, \textcolor{stringliteral}{"."});
1131             strcat ( acceptedstrings, suffix);
1132 
1133             acceptedreads.open ( acceptedstrings );
1134             acceptedreads.close();
1135         \}
1136         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a2cd647a5df32ab9cad67cb8a452d7aec}{samout\_gv} )
1137         \{
1138             \textcolor{comment}{/* sam output for all reads */}
1139             FILE* outfile;
1140 
1141             \textcolor{comment}{/* sam output */}
1142             acceptedstrings\_sam = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[1000]();
1143             \textcolor{keywordflow}{if} ( acceptedstrings\_sam == NULL )
1144             \{
1145                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for acceptedstrings\_sam
       (paralleltraversal.cpp)\(\backslash\)n"});
1146                 exit(EXIT\_FAILURE);
1147             \}
1148             strcpy( acceptedstrings\_sam, ptr\_filetype\_ar );
1149             strcat( acceptedstrings\_sam, \textcolor{stringliteral}{".sam"});
1150 
1151             outfile = fopen (acceptedstrings\_sam,\textcolor{stringliteral}{"w"});
1152             fclose(outfile);
1153         \}
1154         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_ae58af383c31c36bdc039b24ea2730b83}{blastout\_gv} )
1155         \{
1156             \textcolor{comment}{/* blast output for all reads */}
1157             FILE* outfile;
1158 
1159             \textcolor{comment}{/* blast output */}
1160             acceptedstrings\_blast = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[1000]();
1161             \textcolor{keywordflow}{if} ( acceptedstrings\_blast == NULL )
1162             \{
1163                 fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for acceptedstrings\_blast
       (paralleltraversal.cpp)\(\backslash\)n"});
1164                 exit(EXIT\_FAILURE);
1165             \}
1166             strcpy( acceptedstrings\_blast, ptr\_filetype\_ar );
1167             strcat( acceptedstrings\_blast, \textcolor{stringliteral}{".blast"});
1168 
1169             outfile = fopen (acceptedstrings\_blast,\textcolor{stringliteral}{"w"});
1170             fclose(outfile);
1171         \}
1172 
1173     \}\textcolor{comment}{//~if ( ptr\_filetype\_ar != NULL )}
1174 
1175     \textcolor{comment}{/* output stream for other reads */}
1176     ofstream otherreads;
1177 
1178     \textcolor{keywordflow}{if} ( ptr\_filetype\_or != NULL )
1179     \{
1180         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a10e5ea4d5132a75aa2fa4947c714d874}{fastxout\_gv} )
1181         \{
1182             \textcolor{comment}{/* add suffix database name to accepted reads file */}
1183             strcat ( ptr\_filetype\_or, \textcolor{stringliteral}{"."} );
1184             strcat ( ptr\_filetype\_or, suffix );
1185 
1186             \textcolor{comment}{/* create the other reads file */}
1187             otherreads.open( ptr\_filetype\_or );
1188             otherreads.close();
1189         \}
1190     \}
1191 
1192 
1193     int32\_t l,k,m;
1194     int8\_t* mat = (int8\_t*)calloc(16, \textcolor{keyword}{sizeof}(int8\_t));
1195 
1196     \textcolor{comment}{/* initialize scoring matrix for genome sequences */}
1197 
1198     \textcolor{keywordflow}{for} (l = k = 0; l < 4; l++) 
1199     \{
1200         \textcolor{keywordflow}{for} (m = 0; m < 4; m++) 
1201             mat[k++] = l == m ? match : mismatch;   \textcolor{comment}{/* weight\_match : -weight\_mismatch */}
1202     \}
1203 
1204 
1205     \textcolor{comment}{/* count the number of nucleotides in the entire reads file (for e-value) */}
1206     eprintf(\textcolor{stringliteral}{"\(\backslash\)n  Computing Gumbel parameters ... "});
1207 
1208     TIME(s);
1209 
1210     \textcolor{keywordtype}{char} ch;
1211     FILE *fp = fopen(inputreads,\textcolor{stringliteral}{"r"});
1212     \textcolor{keywordflow}{if} (fp==NULL)
1213     \{
1214         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not open reads file - %s"},strerror(errno));
1215         exit(EXIT\_FAILURE);
1216     \}
1217     \textcolor{comment}{/* FASTA */}
1218     \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1219     \{
1220         \textcolor{keywordflow}{while} ( (ch=getc(fp)) != EOF )
1221         \{
1222             \textcolor{keywordflow}{if} ( ch == \textcolor{charliteral}{'>'} )
1223             \{
1224                 \hyperlink{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}{number\_total\_read\_gv}++;
1225                 \textcolor{keywordflow}{while} ( (ch=getc(fp)) != \textcolor{charliteral}{'\(\backslash\)n'} );
1226             \}
1227 
1228             ch=getc(fp);
1229 
1230             \textcolor{keywordflow}{while} ( (ch != EOF) && (ch != \textcolor{charliteral}{'>'}) ) 
1231             \{
1232                 \textcolor{keywordflow}{if} ( (ch != \textcolor{charliteral}{'\(\backslash\)n'}) && (ch != \textcolor{charliteral}{' '}) )
1233                     \hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv}++;
1234                 ch=getc(fp);
1235             \}
1236             ungetc(ch,fp);
1237         \}
1238     \}
1239     \textcolor{comment}{/* FASTQ */}
1240     \textcolor{keywordflow}{else}
1241     \{
1242         \textcolor{keywordtype}{int} nc = 0;
1243 
1244         \textcolor{keywordflow}{while} ( (ch=getc(fp)) != EOF )
1245         \{
1246             \textcolor{keywordflow}{if} ( ch == \textcolor{charliteral}{'\(\backslash\)n'} ) nc++;
1247             \textcolor{keywordflow}{if} ( ((nc-1)%4 == 0) && (ch != \textcolor{charliteral}{'\(\backslash\)n'}))
1248                 \hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv}++;
1249         \}
1250 
1251         \hyperlink{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}{number\_total\_read\_gv}=nc/4;
1252     \}
1253 
1254     fclose(fp); 
1255 
1256     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} num\_index\_parts = 0;
1257 
1258     \textcolor{comment}{/* compute gumbel parameters */}
1259     \hyperlink{paralleltraversal_8cpp_a7184e9ff23e16d0428e13221eaa1705e}{compute\_gumbel} ( match, mismatch, gap\_open,   gap\_extension, root, path, num\_index\_parts,
       acceptedstrings\_sam, ptr\_filetype\_ar, argv, argc );
1260 
1261     TIME(f);
1262 
1263     eprintf(\textcolor{stringliteral}{"done [%.2f sec]\(\backslash\)n"}, (f-s) );
1264 
1265     eprintf(\textcolor{stringliteral}{"  seed length = %d\(\backslash\)n"},\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv});
1266     eprintf(\textcolor{stringliteral}{"  number of seeds = %d\(\backslash\)n"},\hyperlink{main_8cpp_a68cd0d4a5619a828337cbd1c4d173ab2}{seed\_hits\_gv});
1267     eprintf(\textcolor{stringliteral}{"  pass 1 = %d, pass 2 = %d, pass 3 = %d\(\backslash\)n"},\hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1},
      \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2},\hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3});
1268     eprintf(\textcolor{stringliteral}{"  edges = %d"},\hyperlink{main_8cpp_ae1fb1584f4110e0fcd92992a0c9f3de2}{edges\_gv});
1269   \textcolor{keywordflow}{if} (\hyperlink{main_8cpp_a44190260369f5270c2a9a16785f81599}{as\_percent\_gv})
1270         eprintf(\textcolor{stringliteral}{" (as percent)\(\backslash\)n"});
1271     \textcolor{keywordflow}{else}
1272         eprintf(\textcolor{stringliteral}{" (as integer)\(\backslash\)n"});     
1273     
1274 
1275     \textcolor{comment}{/* mmap the file by windows of size ~1GB (pow(2,30)) */}
1276     \textcolor{keywordflow}{while} ( file\_s < file\_sections )
1277     \{
1278         eprintf(\textcolor{stringliteral}{"\(\backslash\)n  Begin partial reads section # %d:\(\backslash\)n"},file\_s+1);
1279 
1280         \textcolor{comment}{/* begin file memory map */}
1281         TIME(s);
1282 
1283     \textcolor{comment}{/* mmap the file into memory */}
1284     raw = (\textcolor{keywordtype}{char}*)mmap ( 0, partial\_file\_size, PROT\_READ, MAP\_SHARED, fd, offset );
1285     \textcolor{keywordflow}{if} ( raw == MAP\_FAILED )
1286     \{
1287             close(fd);
1288             fprintf(stderr,\textcolor{stringliteral}{"  Error mmapping the file\(\backslash\)n"});
1289             exit(EXIT\_FAILURE);
1290     \}
1291 
1292       \textcolor{keywordtype}{size\_t} strs = 0;
1293 
1294         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} total\_reads\_mapped = 0;
1295 
1296         \textcolor{comment}{/* covers the case when a bridge read is cut before the first '\(\backslash\)n' symbol */}
1297         \textcolor{keywordtype}{bool} goback = \textcolor{keyword}{false};
1298 
1299     \textcolor{comment}{/* the offset of bridge reads at the beginning and end of the file */}
1300     \textcolor{keywordtype}{int} reads\_offset\_f = 0;
1301     \textcolor{keywordtype}{int} reads\_offset\_e = 0;
1302 
1303         \textcolor{keywordtype}{int} offset\_pair\_top = 0;
1304         \textcolor{keywordtype}{int} offset\_pair\_bottom = 0; 
1305 
1306         \{
1307         \textcolor{comment}{/* beginning of file section */}
1308       \textcolor{keywordtype}{char} *start = &raw[0];
1309 
1310         \textcolor{comment}{/* end of file section */}
1311       \textcolor{keywordtype}{char} *end = &raw[partial\_file\_size-1];
1312 
1313         \textcolor{comment}{/* count the number of strings in the file window (FASTA) */}
1314         \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1315         \{
1316             \textcolor{comment}{/* compute the reads offset length at top of file section }
1317 \textcolor{comment}{         (the first character can be '>' where reads\_offset\_f = 0) */}
1318             \textcolor{keywordflow}{while} ( *start++ != \textcolor{charliteral}{'>'} )
1319             \{   
1320                 reads\_offset\_f++; 
1321             \}
1322 
1323             \textcolor{comment}{/* compute the reads offset length at bottom of file section }
1324 \textcolor{comment}{               (always assume the read is split since we don't know the }
1325 \textcolor{comment}{               number of new lines per entry) */}
1326             \textcolor{keywordflow}{do} 
1327             \{
1328                 reads\_offset\_e++;
1329             \} \textcolor{keywordflow}{while} ( *end-- != \textcolor{charliteral}{'>'} );
1330 
1331             \textcolor{comment}{/* since we don't know the length of the split read, we always }
1332 \textcolor{comment}{         count back the end of file offset (reads\_offset\_e) to the first '>' symbol */}
1333             goback = \textcolor{keyword}{true};
1334 
1335             \textcolor{comment}{/* count the number of strings in the file section */}
1336             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{size\_t} i = reads\_offset\_f; i < (size\_t)partial\_file\_size-reads\_offset\_e; i++ )
1337             \{
1338                 \textcolor{keywordflow}{if} ( raw[i] == \textcolor{charliteral}{'>'} ) strs+=2;
1339             \}
1340 
1341             \textcolor{comment}{/* the adjacent paired read comes after the split read }
1342 \textcolor{comment}{                (for the paired read at the TOP of the file section) */}
1343             \textcolor{keywordflow}{if} ( offset\_top )
1344             \{
1345                 strs-=2;
1346                 \textcolor{comment}{/* increase the read's offset for the top of the file to }
1347 \textcolor{comment}{           enclose the paired read */}
1348                 \textcolor{keywordflow}{while} ( *start++ != \textcolor{charliteral}{'>'} ) reads\_offset\_f++;
1349             \}
1350 
1351             \textcolor{comment}{/* the adjacent paired read comes before the split read }
1352 \textcolor{comment}{                (for the paired read at the BOTTOM of the file section) */}
1353             \textcolor{keywordflow}{if} ( strs%4 == 2 )
1354             \{
1355                 offset\_bottom = \textcolor{keyword}{true};
1356             \}
1357 
1358             \textcolor{comment}{/* increase the read's offset for the bottom of the file to}
1359 \textcolor{comment}{         enclose the paired read */}
1360             \textcolor{keywordflow}{if} ( offset\_bottom )
1361             \{
1362                 strs-=2;
1363                 \textcolor{keywordflow}{do}
1364                 \{
1365                     reads\_offset\_e++;
1366                 \} \textcolor{keywordflow}{while} ( *end-- != \textcolor{charliteral}{'>'} );
1367             \}
1368         
1369             \textcolor{comment}{/* the last file section does not contain a split read at the end,}
1370 \textcolor{comment}{         but we need to count in the read which is masked by reads\_offset\_e */}
1371             \textcolor{keywordflow}{if} ( file\_s == file\_sections-1 )
1372             \{
1373                 \textcolor{keywordflow}{if} ( offset\_bottom )
1374                     strs+=4;
1375                 \textcolor{keywordflow}{else}
1376                     strs+=2;
1377             \}
1378             \textcolor{comment}{/* account for the split read and its pair */}
1379             \textcolor{keywordflow}{if} ( file\_s > 0 && ( reads\_offset\_f > 0 || offset\_top ) )
1380                 strs+=4;
1381 
1382         \} \textcolor{comment}{//~(FASTA)}
1383 
1384         \textcolor{comment}{/* (FASTQ) count the number of strings in the file section */}
1385         \textcolor{keywordflow}{else}
1386         \{
1387             \textcolor{keywordtype}{int} newlinecounter = 0;
1388 
1389         \textcolor{comment}{/* count the number of strings in the file section */}
1390         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{size\_t} i = 0; i < (size\_t)partial\_file\_size; i++ )
1391         \{
1392                 \textcolor{keywordflow}{if} ( raw[i] == \textcolor{charliteral}{'\(\backslash\)n'} ) strs++;
1393         \}
1394 
1395             \textcolor{comment}{/* if the number of full 4 line entries is a multiple of 4 */}
1396             \textcolor{keywordflow}{if} ( (num\_newlines\_bottom = (strs-num\_newlines\_top)%4) == 0 )
1397             \{
1398                 \textcolor{comment}{/* and the last character is not a new line  */}
1399                 \textcolor{keywordflow}{if} ( raw[partial\_file\_size-1] != \textcolor{charliteral}{'\(\backslash\)n'} ) 
1400                     goback = \textcolor{keyword}{true};      
1401             \}
1402 
1403             \textcolor{comment}{/* the number of full 4 line entries - num\_newlines\_top - num\_newlines\_bottom */}
1404             \textcolor{keywordtype}{int} full\_entries = strs - num\_newlines\_top - num\_newlines\_bottom; 
1405 
1406             \textcolor{keywordflow}{if} ( offset\_top )
1407             \{
1408                 full\_entries-=4;
1409             \}
1410 
1411             \textcolor{keywordflow}{if} ( (full\_entries/4)%2 == 1 )
1412             \{
1413                 offset\_bottom = \textcolor{keyword}{true};
1414                 full\_entries-=4;
1415             \}
1416             
1417             \textcolor{comment}{/* compute the reads offset length at top of file section */}
1418             \textcolor{keywordflow}{if} ( num\_newlines\_top > 0 or offset\_top )
1419             \{
1420                 \textcolor{keywordflow}{if} ( offset\_top )
1421                     offset\_pair\_top = 4;
1422 
1423                 \textcolor{keywordflow}{while} ( newlinecounter < num\_newlines\_top + offset\_pair\_top ) 
1424                 \{
1425               reads\_offset\_f++; 
1426                     \textcolor{keywordflow}{if} ( *start++ == \textcolor{charliteral}{'\(\backslash\)n'} ) 
1427                         newlinecounter++;
1428                 \}   
1429 
1430                 \textcolor{comment}{/* reset the counter */}
1431                 newlinecounter = 0;
1432       \} 
1433 
1434             \textcolor{comment}{/* compute the reads offset length at bottom of file section */}
1435             \textcolor{keywordflow}{if} ( num\_newlines\_bottom > 0 or goback or offset\_bottom )
1436             \{
1437                 \textcolor{keywordflow}{if} ( offset\_bottom )
1438                     offset\_pair\_bottom = 4;
1439 
1440             \textcolor{keywordflow}{while} ( newlinecounter < num\_newlines\_bottom + 1 + offset\_pair\_bottom ) 
1441             \{ 
1442                 reads\_offset\_e++; 
1443                     \textcolor{keywordflow}{if} ( *end-- == \textcolor{charliteral}{'\(\backslash\)n'} )
1444                         newlinecounter++;
1445         \}
1446                 reads\_offset\_e--;
1447 
1448                 \textcolor{comment}{/* reset the counter */}
1449                 newlinecounter = 0;
1450             \}
1451 
1452             strs = full\_entries/2;
1453     
1454             \textcolor{comment}{/* account for the bridged read if exists (4 extra pointers to 2 paired reads) */}
1455             \textcolor{keywordflow}{if} ( file\_s > 0 && ( num\_newlines\_top > 0 || offset\_top ) ) strs+=4;
1456 
1457         \}\textcolor{comment}{//~FASTQ bridge}
1458 
1459         \}\textcolor{comment}{//~range of *start and *end pointers}
1460 
1461       \textcolor{comment}{/* create a char* array for pointers to each string in mmap */}
1462         \textcolor{keywordtype}{char}** reads = \textcolor{keyword}{new} \textcolor{keywordtype}{char}*[strs]();
1463     \textcolor{keywordflow}{if} ( reads == NULL )
1464         \{
1465             cerr << \textcolor{stringliteral}{"\(\backslash\)n  ERROR: cannot allocate memory for reads\(\backslash\)n\(\backslash\)n"};
1466             exit(EXIT\_FAILURE);
1467         \}
1468 
1469     \textcolor{comment}{/* record the end of the bridge read */}
1470     \textcolor{keywordflow}{if} ( file\_s > 0 )
1471     \{
1472             \textcolor{keywordflow}{if} ( reads\_offset\_f > 0 || offset\_top )
1473             \{
1474             \textcolor{keywordtype}{char}* start = &raw[0];
1475                 \textcolor{keywordtype}{char} *end = &raw[reads\_offset\_f];
1476 
1477                 \textcolor{keywordflow}{while} ( start != end )
1478                 \{
1479                     *bridgeptr++ = *start++;
1480                 \}
1481 
1482               \textcolor{comment}{/* signify end of bridgeread */}
1483                 \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1484                 *bridgeptr = \textcolor{charliteral}{'\(\backslash\)0'};
1485 
1486                 \textcolor{comment}{/* add the bridge reads (pair) to the start of reads to be filtered */}
1487                 start = bridgeread;
1488 
1489                 \textcolor{comment}{/* first read */}
1490                 reads[0] = start;
1491                 \textcolor{keywordflow}{while} ( *start++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1492                 reads[1] = start;   
1493                 \textcolor{keywordtype}{int} newlines = 0;
1494 
1495                 \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'@'} )
1496                 \{
1497                     \textcolor{comment}{/* go to second read in fastq format */}
1498                     \textcolor{keywordflow}{while} ( newlines < 3 )
1499                     \{
1500                         \textcolor{keywordflow}{if} ( *start++ == \textcolor{charliteral}{'\(\backslash\)n'} )
1501                             newlines++;
1502                     \}
1503                 \}
1504                 \textcolor{keywordflow}{else}
1505                 \{
1506                     \textcolor{comment}{/* go to second read in fasta format */}
1507                     \textcolor{keywordflow}{while} ( *start != \textcolor{charliteral}{'>'}) start++;
1508                 \}
1509 
1510                 \textcolor{comment}{/* second read */}
1511                 reads[2] = start;
1512                 \textcolor{keywordflow}{while} ( *start++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1513                 reads[3] = start;
1514             \}
1515         \}\textcolor{comment}{//~if ( file\_s > 0 )}
1516 
1517       \textcolor{comment}{/* a pointer is added to each header and the directly following read,}
1518 \textcolor{comment}{           hence the number of pointers for a fasta or fastq file is the same  */}
1519         \textcolor{comment}{/* (FASTA) */}
1520       \textcolor{keywordtype}{char}* line = &raw[reads\_offset\_f];
1521         \textcolor{keywordtype}{char}* finalnt = &raw[partial\_file\_size-1-reads\_offset\_e];
1522         \textcolor{keywordtype}{int} minlenread = 100000;
1523         \textcolor{keywordtype}{int} readlen = 0;
1524 
1525         \textcolor{keywordtype}{int} index = 0;
1526 
1527         \textcolor{keywordflow}{if} ( file\_s > 0 && ( reads\_offset\_f > 0 || offset\_top ) )
1528             index = 4;
1529         \textcolor{keywordflow}{else} 
1530             index = 0;
1531 
1532         \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1533         \{
1534             \textcolor{keywordflow}{while} ( line != finalnt+1 && *line != EOF )
1535             \{
1536                 \textcolor{keywordflow}{if} ( *line == \textcolor{charliteral}{'>'} )
1537                 \{
1538                         \textcolor{comment}{/* the read tag */}
1539                         reads[index++] = line;
1540                         \textcolor{keywordflow}{while} ( *line++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1541 
1542                         \textcolor{comment}{/* the read */}
1543                         reads[index++] = line;
1544                 \}
1545 
1546                 readlen = 0;
1547 
1548                 \textcolor{keywordflow}{while} ( *line != EOF && *line != \textcolor{charliteral}{'>'} )
1549                 \{
1550                         \textcolor{keywordflow}{if} ( *line != \textcolor{charliteral}{'\(\backslash\)n'} )
1551                             readlen++;
1552                         line++;
1553                 \}
1554 
1555                 \textcolor{comment}{/* compute the minimum length read */}
1556                     \textcolor{keywordflow}{if} ( readlen >= 20 )
1557                     readlen < minlenread ? minlenread = readlen : minlenread; 
1558             \}
1559 
1560             \textcolor{comment}{/* if we are on the last file section, add a pointer to the last read}
1561 \textcolor{comment}{         (and its paired read if it exists) */}
1562             \textcolor{keywordflow}{if} ( file\_s == file\_sections-1 )
1563             \{
1564                 \textcolor{keywordtype}{int} x = 0;
1565                 \textcolor{keywordflow}{if} ( offset\_bottom )
1566                     x = 4;
1567                 \textcolor{keywordflow}{else}    
1568                     x = 2;
1569 
1570                 \textcolor{comment}{/* last read */}
1571                 \textcolor{keywordtype}{char} *tmp = &raw[partial\_file\_size-reads\_offset\_e];
1572                 reads[strs-x] = tmp;
1573 
1574                 \textcolor{keywordflow}{while} ( *tmp++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1575                 reads[strs-x+1] = tmp;
1576             
1577                 \textcolor{comment}{/* accompanying paired read */}
1578                 \textcolor{keywordflow}{if} ( offset\_bottom )    
1579                 \{
1580                     \textcolor{keywordflow}{while} ( *tmp != \textcolor{charliteral}{'\(\backslash\)0'} && *tmp != \textcolor{charliteral}{'>'} ) tmp++;
1581                     reads[strs-2] = tmp;
1582 
1583                     \textcolor{keywordflow}{while} ( *tmp++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1584                     reads[strs-1] = tmp;
1585                 \}
1586             \}       
1587             
1588         \}\textcolor{comment}{//~if ( filesig == '>' )}
1589 
1590         \textcolor{comment}{/* (FASTQ) */}
1591         \textcolor{keywordflow}{else} 
1592         \{
1593             \textcolor{comment}{/* line counter (4 lines per fastq entry) */}
1594             \textcolor{keywordtype}{int} count = 0;
1595 
1596             \textcolor{keywordflow}{while} ( line != finalnt && *line != \textcolor{charliteral}{'\(\backslash\)0'} )
1597             \{
1598                  \textcolor{keywordflow}{if} ( count%4 == 0 )
1599                  \{
1600                     \textcolor{comment}{/* the read tag */}
1601                     reads[index++] = line;  
1602                     \textcolor{keywordflow}{while} ( *line++ != \textcolor{charliteral}{'\(\backslash\)n'} );
1603 
1604                     \textcolor{comment}{/* the read */}
1605                     reads[index++] = line;
1606 
1607                     \textcolor{comment}{/* compute the read length */}
1608                     \textcolor{keywordflow}{while} ( *line++ != \textcolor{charliteral}{'\(\backslash\)n'} ) readlen++;
1609                     \textcolor{keywordflow}{if} ( readlen >= 20 )
1610                         readlen < minlenread ? minlenread = readlen : minlenread;
1611 
1612                     readlen = 0;
1613 
1614                     count+=2;
1615 
1616                     \textcolor{comment}{/* skip the quality .. */}
1617                \}
1618 
1619                 \textcolor{keywordflow}{if} ( *line++ == \textcolor{charliteral}{'\(\backslash\)n'} ) count++;
1620 
1621             \}
1622       \}\textcolor{comment}{//~if ( filesig == '@' )}
1623 
1624         TIME(f);
1625 
1626         \textcolor{comment}{/* first bilan entry */}
1627         \hyperlink{paralleltraversal_8cpp_a192f0b0d3603008657d8cee829933644}{total\_read\_gv} += (int)strs/2;
1628 
1629       eprintf(\textcolor{stringliteral}{"  Time to mmap reads and set up pointers             [%.2f sec]\(\backslash\)n"}, (f-s) );
1630 
1631 
1632         \textcolor{comment}{/* array of bits to represent all reads, a bit representing an accepted read is set to 1 (for
       --fastx option) */}
1633         vector<bool> read\_hits((\textcolor{keywordtype}{int})strs/2);
1634 
1635         \textcolor{comment}{/* map storing the read number and the best alignment information */}
1636         map <unsigned int, s\_align> read\_hits\_align\_info;
1637 
1638         \textcolor{comment}{/* number of bytes of reference sequences to read */}
1639         \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}* seq\_part\_size = \textcolor{keyword}{new} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}[num\_index\_parts]();
1640         \textcolor{keywordflow}{if} ( seq\_part\_size == NULL )
1641         \{
1642             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for seq\_part\_size (paralleltraversal.cpp)\(\backslash\)n"}
      );
1643             exit(EXIT\_FAILURE);
1644         \}
1645 
1646         \textcolor{comment}{/* number of reference sequences to load in this index part */}
1647         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* numseq\_part = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}[num\_index\_parts]();
1648         \textcolor{keywordflow}{if} ( numseq\_part == NULL )
1649         \{
1650             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for numseq\_part (paralleltraversal.cpp)\(\backslash\)n"});
1651             exit(EXIT\_FAILURE);
1652         \}
1653 
1654         \textcolor{comment}{/* pointer to the first reference sequence to load in this index part */}
1655         \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}* start\_part = \textcolor{keyword}{new} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int}[num\_index\_parts]();
1656         \textcolor{keywordflow}{if} ( start\_part == NULL )
1657         \{
1658             fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for start\_part (paralleltraversal.cpp)\(\backslash\)n"});
1659             exit(EXIT\_FAILURE);
1660         \}
1661 
1662         \textcolor{comment}{/* covert part number into a string */}
1663         stringstream prt\_str;
1664         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} part = 0;
1665         prt\_str << part;
1666         \textcolor{keywordtype}{string} part\_str = prt\_str.str();
1667 
1668         eprintf(\textcolor{stringliteral}{"    Begin analysis of: %s\(\backslash\)n"}, ptr\_dbfile);
1669 
1670         \textcolor{comment}{/* for each partial file of burst trie index (part\_0 .. part\_x) */}  
1671         \textcolor{keywordflow}{for} ( part = 0; part < num\_index\_parts; part++ )
1672         \{
1673                 eprintf(\textcolor{stringliteral}{"    Loading index part %d/%u  ...                    "},part+1,num\_index\_parts );
1674 
1675                 TIME(s);
1676 
1677                 \textcolor{comment}{/* memory buffer to store the reference sequence database */}
1678                 \textcolor{keywordtype}{char}* buffer = NULL;
1679                 \textcolor{comment}{/* pointer to start of each sequence in buffer */}
1680                 \textcolor{keywordtype}{char}** reference\_seq = NULL;
1681                 \textcolor{comment}{/* length of each sequence in buffer */}
1682                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* reference\_seq\_len = NULL;
1683                 \textcolor{comment}{/* 9-mer look-up tables */}
1684                 kmer *lookup\_tbl = NULL;
1685                 \textcolor{comment}{/* 19-mer position look-up tables */}
1686                 kmer\_origin* positions\_tbl = NULL;
1687                 \textcolor{comment}{/* number of elements in the table */}
1688                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} number\_elements = 0;
1689 
1690 
1691 \textcolor{preprocessor}{                #pragma omp master}
1692 \textcolor{preprocessor}{}                \{
1693                     \textcolor{comment}{/* 2. load the index part (9-mer lookup table, mini-burst tries and positions table) */}
1694                     \hyperlink{paralleltraversal_8cpp_a5be67e3f479b18a9976e0e8ed5e3ce32}{load\_index}(root, 
1695                                         path, 
1696                                         part\_str, 
1697                                         (start\_part+part), 
1698                                         (seq\_part\_size+part),
1699                                         (numseq\_part+part),
1700                                         lookup\_tbl,
1701                                         positions\_tbl,
1702                                         number\_elements );
1703 
1704                     \textcolor{comment}{/* block of memory to hold all ids + reference sequences */}
1705                     buffer = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[(seq\_part\_size[part]+1)]();
1706                     \textcolor{keywordflow}{if} ( buffer == NULL )
1707                     \{
1708                         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for reference sequence buffer
       (paralleltraversal.cpp)\(\backslash\)n"});
1709                         exit(EXIT\_FAILURE);
1710                     \}
1711 
1712                     \textcolor{comment}{/* pointer to the start of every sequence in the buffer */}
1713                     reference\_seq = \textcolor{keyword}{new} \textcolor{keywordtype}{char}*[(numseq\_part[part]<<1)]();
1714                     \textcolor{keywordflow}{if} ( reference\_seq == NULL )
1715                     \{
1716                         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for reference\_seq
       (paralleltraversal.cpp)\(\backslash\)n"});
1717                         exit(EXIT\_FAILURE);
1718                     \} 
1719 
1720                     \textcolor{comment}{/* length of every sequence in the buffer */}
1721                     reference\_seq\_len = \textcolor{keyword}{new} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}[numseq\_part[part]]();
1722                     \textcolor{keywordflow}{if} ( reference\_seq\_len == NULL )
1723                     \{
1724                         fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for reference\_seq\_len
       (paralleltraversal.cpp)\(\backslash\)n"});
1725                         exit(EXIT\_FAILURE);
1726                     \}
1727 
1728 
1729                     \textcolor{comment}{/* load the reference sequences for SW alignment */}
1730                     \hyperlink{paralleltraversal_8cpp_a2790ed8252fe8ba0732735cce725c4bc}{load\_ref}(ptr\_dbfile,buffer,reference\_seq,reference\_seq\_len,seq\_part\_size[part],
      numseq\_part[part],start\_part[part],1);
1731                 \}
1732                 TIME(f);
1733 
1734                 eprintf(\textcolor{stringliteral}{" done   [%.2f sec]\(\backslash\)n"},(f-s) );
1735 
1736                 eprintf(\textcolor{stringliteral}{"    Begin index search ... "});
1737 
1738 
1739 
1740 
1741                 \textcolor{comment}{/* begin the parallel traversal */}
1742                 TIME(s);
1743 
1744                 \textcolor{keywordtype}{int} bit\_vector\_size = (\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-2)<<2;
1745                 \textcolor{keywordtype}{int} offset = (\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-3)<<2;
1746 
1747                 \textcolor{comment}{/* only search the forward xor reverse strand */}
1748                 \textcolor{keywordtype}{int} max = 0;
1749 
1750                 \hyperlink{main_8cpp_aeb939919c5625c41da3e53c1deb325c3}{forward\_gv} = \textcolor{keyword}{true};
1751 
1752                 \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_aeb939919c5625c41da3e53c1deb325c3}{forward\_gv} ^ \hyperlink{main_8cpp_a2cf82271f0611f7d3fdf3b8919e57c03}{reverse\_gv} ) max = 1;
1753                 \textcolor{comment}{/* search both strands */}
1754                 \textcolor{keywordflow}{else} max = 2;
1755 
1756                 \textcolor{comment}{/* search the forward and/or reverse strands */}
1757                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} strand = 0; strand < max; strand++ )
1758                 \{
1759                     \textcolor{comment}{/* loop through all of the reads in the file */}
1760 \textcolor{preprocessor}{                    #pragma omp parallel for num\_threads(numcpu\_gv)
       shared(lookup\_tbl,positions\_tbl,buffer,reference\_seq,reference\_seq\_len)}
1761 \textcolor{preprocessor}{}                    \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} readn = 1; readn < (int)strs; readn+=2 )
1762                     \{
1763                         \textcolor{comment}{/* read on integer alphabet \{0,1,2,3\} */}
1764                         \textcolor{keywordtype}{char} myread[READLEN];
1765                         \textcolor{keywordtype}{char} myread\_rc[READLEN];
1766                         \textcolor{keywordtype}{char}* str = reads[readn];
1767                         \textcolor{keywordtype}{char}* \_myread = &myread[0]; 
1768 
1769                         \textcolor{comment}{/* length of read */}
1770                         \textcolor{keywordtype}{int} readlen = 0;
1771 
1772                         \textcolor{comment}{/* change the read into an integer alphabet -- FASTA */}
1773                         \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
1774                         \{
1775                             \textcolor{keywordflow}{while} ( *str != \textcolor{charliteral}{'\(\backslash\)0'} && *str != \textcolor{charliteral}{'>'} )
1776                       \{
1777                                 \textcolor{keywordflow}{if} ( *str != \textcolor{charliteral}{'\(\backslash\)n'} ) 
1778                                 \{
1779                                 *\_myread++ = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[(int)*str];
1780                                 readlen++;
1781                                     \textcolor{keywordflow}{if} ( readlen > READLEN )
1782                                     \{
1783                                         fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: at least one of your reads is > %d nt \(\backslash\)n
      "},READLEN);
1784                           fprintf(stderr,\textcolor{stringliteral}{"  Please check your reads or contact the authors.\(\backslash\)n"});
1785                                         exit(EXIT\_FAILURE);
1786                                     \}
1787                                 \}
1788                                 str++;                      
1789                       \}
1790                         \}
1791                         \textcolor{comment}{/* change the read into an integer alphabet -- FASTQ */}
1792                         \textcolor{keywordflow}{else}
1793                         \{
1794                             \textcolor{keywordflow}{while} ( *str != \textcolor{charliteral}{'\(\backslash\)n'} )
1795                       \{
1796                                 *\_myread++ = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[(int)*str++];
1797                             readlen++;
1798                                 \textcolor{keywordflow}{if} ( readlen > READLEN )
1799                                 \{
1800                                     fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: at least one of your reads is > %d nt \(\backslash\)n"},
      READLEN);
1801                                     fprintf(stderr,\textcolor{stringliteral}{"  Please check your reads or contact the authors.\(\backslash\)n"});
1802                                     exit(EXIT\_FAILURE);
1803                                 \}
1804                       \}
1805                         \}
1806 
1807                         \textcolor{comment}{/* the read length is too short */}
1808                         \textcolor{keywordflow}{if} ( readlen < \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} )
1809                         \{
1810                             fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  WARNING: At least one of the reads is of shorter length
       than %d nucleotides, "}, \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv});
1811                             fprintf(stderr,\textcolor{stringliteral}{"by default it will not be searched\(\backslash\)n "});
1812                             \textcolor{keywordflow}{continue};
1813                         \}
1814 
1815                         \textcolor{comment}{/* create the reverse strand */}
1816                         \textcolor{keywordflow}{if} ( reverse\_gv && !\hyperlink{main_8cpp_aeb939919c5625c41da3e53c1deb325c3}{forward\_gv} )
1817                         \{
1818                             \textcolor{comment}{/* faster than xor algorithm */}
1819                             \textcolor{keywordtype}{char}* revcomp = &myread[readlen-1];
1820 
1821                             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < readlen; j++ )
1822                             myread\_rc[j] = \hyperlink{paralleltraversal_8cpp_adf8e093429055846312e4c3c3d564c1f}{complement}[(\textcolor{keywordtype}{int})*revcomp--];
1823 
1824                             memcpy(&myread[0],&myread\_rc[0],READLEN);
1825                         \}\textcolor{comment}{//~if (REVERSE)}
1826 
1827                         \textcolor{comment}{/* array of positions of window hits on the reference sequence */}
1828                         vector< id\_win > id\_win\_hits;
1829                         \textcolor{comment}{/* number of windows hit to the reference sequence(s) */}
1830                         \textcolor{keywordtype}{int} readhit = 0;
1831                         \textcolor{keywordtype}{int} windowshift = \hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1};
1832 
1833 
1834                         \textcolor{comment}{/* loop for each new Pass to granulate seed search intervals */}
1835                         \textcolor{keywordtype}{bool} search = \textcolor{keyword}{true};
1836                         \textcolor{keywordflow}{do} 
1837                         \{   
1838                             \textcolor{keywordtype}{int} numwin = (readlen-\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}+windowshift)/windowshift;
1839                             \textcolor{keywordtype}{int} read\_index = 0;
1840                     
1841                             \textcolor{comment}{/* iterate over windows of the template string */}
1842                             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} win\_num = 0; win\_num < numwin; win\_num++ )
1843                             \{
1844                                 \textcolor{keywordflow}{if} ( windowshift == \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2} )
1845                                     \textcolor{comment}{/* skip over windows searched by previous pass */}
1846                                     \textcolor{keywordflow}{if} ( read\_index == 0 || read\_index%
      \hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1} == 0 )
1847                                         \textcolor{keywordflow}{goto} check\_score;
1848                     
1849                                 \textcolor{keywordflow}{if} ( windowshift == \hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3} )
1850                                     \textcolor{comment}{/* skip over windows searched by previous pass */}
1851                                     \textcolor{keywordflow}{if} ( read\_index == 0 || read\_index%
      \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2} == 0 )
1852                                         \textcolor{keywordflow}{goto} check\_score;
1853 
1854 
1855                                 \{
1856                                 \textcolor{comment}{/* this flag it set to true if a match is found during subsearch 1(a), to
       skip subsearch 1(b) */}
1857                                     \textcolor{keywordtype}{bool} accept\_zero\_kmer = \textcolor{keyword}{false};                  
1858                                     \textcolor{comment}{/* ids for k-mers that hit the database */}
1859                                     vector< id\_win > id\_hits;
1860 
1861                                     MYBITSET bitwindowsf[bit\_vector\_size];
1862                                     memset(&bitwindowsf[0],0,bit\_vector\_size);
1863 
1864                                     \textcolor{comment}{/* build the first bitvector window */}
1865                                     \hyperlink{bitvector_8cpp_ae329187fe262a80a646448a8d33c6a5d}{init\_win\_f}( &myread[read\_index+
      \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}],  
1866                                                 \textcolor{comment}{/* [w\_1] forward k = 1 */}
1867                                                 \textcolor{comment}{/* bitwindows[0][0][0] */}
1868                                                 &bitwindowsf[0], 
1869                                                 \textcolor{comment}{/* bitwindows[0][1][0] */}
1870                                                 &bitwindowsf[4]
1871                                                 );
1872 
1873                                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} keyf = 0;
1874                                     \textcolor{keywordtype}{char} *keyf\_ptr = &myread[read\_index];
1875 
1876                                     \textcolor{comment}{/* build hash for first half windows (foward and reverse) */}
1877                                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} g = 0; g < \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}; g++ )
1878                                         (keyf <<= 2) |= (int)*keyf\_ptr++;
1879 
1880 
1881                                     \textcolor{comment}{/* do traversal if the exact half window exists in the burst trie */}
1882                                     \textcolor{keywordflow}{if} ( (lookup\_tbl[keyf].count > 0) && (lookup\_tbl[keyf].trie\_F != NULL) 
      )
1883                                     \{
1884                                         \textcolor{comment}{/* subsearch (1)(a) d([p\_1],[w\_1]) = 0 and d([p\_2],[w\_2]) <= 1; }
1885 \textcolor{comment}{                                        * }
1886 \textcolor{comment}{                                        *   w = |------ [w\_1] ------|------ [w\_2] ------|}
1887 \textcolor{comment}{                                        *   p = |------ [p\_1] ------|------ [p\_2] ----| (0/1 deletion in
       [p\_2])}
1888 \textcolor{comment}{                                        *                   or}
1889 \textcolor{comment}{                                        *     = |------ [p\_1] ------|------ [p\_2] ------|   (0/1 match/
      substitution in [p\_2])}
1890 \textcolor{comment}{                                        *               or}
1891 \textcolor{comment}{                                        *     = |------ [p\_1] ------|------ [p\_2] --------| (0/1 insertion
       in [p\_2])}
1892 \textcolor{comment}{                                        *}
1893 \textcolor{comment}{                                        */}
1894 
1895                                 
1896                                         \hyperlink{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}{traversetrie\_align} ( lookup\_tbl[keyf].trie\_F,
1897                                                                 0,
1898                                                                 0,
1899                                                                 \textcolor{comment}{/* win2f\_k1\_ptr */}
1900                                                                 &bitwindowsf[0],
1901                                                                 \textcolor{comment}{/* win2f\_k1\_full */}
1902                                                                 &bitwindowsf[offset],
1903                                                                 accept\_zero\_kmer,
1904                                                                 id\_hits,
1905                                                                 readn,
1906                                                                 read\_index
1907                                                                 );
1908                                 
1909                                     \}\textcolor{comment}{//~if exact half window exists in the burst trie}
1910                         
1911 
1912                                     \textcolor{comment}{/* only search if an exact match has not been found */}
1913                                     \textcolor{keywordflow}{if} ( !accept\_zero\_kmer )
1914                                     \{
1915                                         MYBITSET bitwindowsr[bit\_vector\_size];
1916                                         memset(&bitwindowsr[0],0,bit\_vector\_size);
1917 
1918                                         \textcolor{comment}{/* build the first bitvector window */}
1919                                         \hyperlink{bitvector_8cpp_af4bcc2bac4c141e09a0ad653d1a55a1c}{init\_win\_r}( &myread[read\_index+partialwin\_gv-1],  
1920                                                     \textcolor{comment}{/* [w\_1] reverse k = 1 */}
1921                                                     \textcolor{comment}{/* bitwindows[0][0][0] */}
1922                                                     &bitwindowsr[0], 
1923                                                     \textcolor{comment}{/* bitwindows[0][1][0] */}
1924                                                     &bitwindowsr[4]
1925                                                     );
1926 
1927                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} keyr = 0;
1928                                         \textcolor{keywordtype}{char} *keyr\_ptr = &myread[read\_index+
      \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}];
1929 
1930                                         \textcolor{comment}{/* build hash for first half windows (foward and reverse) */}
1931                                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} g = 0; g < \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}; g++ )
1932                                             (keyr <<= 2) |= (int)*keyr\_ptr++;
1933 
1934                                         \textcolor{comment}{/* continue subsearch (1)(b) */}
1935                                         \textcolor{keywordflow}{if} ( (lookup\_tbl[keyr].count > 0) && (lookup\_tbl[keyr].trie\_R != 
      NULL) )
1936                                         \{
1937                                                 \textcolor{comment}{/* subsearch (1)(b) d([p\_1],[w\_1]) = 1 and d([p\_2],[w\_2]) =
       0;  }
1938 \textcolor{comment}{                                                *}
1939 \textcolor{comment}{                                                *   w =    |------ [w\_1] ------|------ [w\_2] -------|}
1940 \textcolor{comment}{                                                *   p =      |------- [p\_1] ---|--------- [p\_2] ----| (1
       deletion in [p\_1])}
1941 \textcolor{comment}{                                                *                   or}
1942 \textcolor{comment}{                                                *     =    |------ [p\_1] ------|------ [p\_2] -------| (1
       match/substitution in [p\_1])}
1943 \textcolor{comment}{                                                *               or}
1944 \textcolor{comment}{                                                *     = |------- [p\_1] --------|---- [p\_2] ---------| (1
       insertion in [p\_1])}
1945 \textcolor{comment}{                                                *}
1946 \textcolor{comment}{                                                */}
1947 
1948                                     
1949                                             \hyperlink{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}{traversetrie\_align} ( lookup\_tbl[keyr].trie\_R,
1950                                                                     0,
1951                                                                     0,
1952                                                                     \textcolor{comment}{/* win1r\_k1\_ptr */}
1953                                                                     &bitwindowsr[0],
1954                                                                     \textcolor{comment}{/* win1r\_k1\_full */}
1955                                                                     &bitwindowsr[offset],
1956                                                                     accept\_zero\_kmer,
1957                                                                     id\_hits,
1958                                                                     readn,
1959                                                                     read\_index
1960                                                                     );  
1961                                     
1962                                         \}\textcolor{comment}{//~if exact half window exists in the reverse burst trie}
1963 
1964                                     \}\textcolor{comment}{//~if (!accept\_zero\_kmer)}
1965 
1966                 
1967                                     \textcolor{comment}{/* associate the ids with the read window number */}
1968                                     \textcolor{keywordflow}{if} ( !id\_hits.empty() )
1969                                     \{
1970                                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (int)id\_hits.size(); i++ )
1971                                         \{
1972                                             id\_win\_hits.push\_back(id\_hits[i]);
1973                                         \}
1974 
1975                                         readhit++;  
1976                                     \}
1977 
1978                                 \}
1979 
1980                                 check\_score:
1981                                 \textcolor{comment}{/* boolean set to true is SW alignment succeeded between the read and a
       candidate reference sequence */}
1982                                 \textcolor{keywordtype}{bool} aligned = \textcolor{keyword}{false};
1983 
1984 
1985                                 \textcolor{comment}{/* output read if matched at more than RATIO windows */}
1986                                 \textcolor{keywordflow}{if} ( win\_num == numwin-1 )
1987                                 \{
1988                                     \textcolor{comment}{/* STEP 1: the number of matching windows on the read to the reference
       database}
1989 \textcolor{comment}{                         is greater than the threshold, continue analysis of read */}
1990                                     \textcolor{keywordflow}{if} ( readhit >= \hyperlink{main_8cpp_a68cd0d4a5619a828337cbd1c4d173ab2}{seed\_hits\_gv} )
1991                                     \{
1992                                         \textcolor{comment}{/* mypair = <number of occurrences of a sequence, index of
       sequence> */}
1993                                         vector<mypair> most\_frequent\_seq;
1994                                         most\_frequent\_seq.reserve(numseq\_part[part]);
1995                                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} i = 0; i < numseq\_part[part]; i++ )
1996                                             most\_frequent\_seq.push\_back(mypair(0,i));
1997 
1998                                         \textcolor{keywordtype}{int} num\_hits = 0;
1999                                         \textcolor{keywordtype}{int} \_id = 0;
2000                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} max\_seq = 0;
2001                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} max\_occur = 0;
2002                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} seq = 0;
2003 
2004                                         \textcolor{comment}{/* STEP 2: for every reference sequence, compute the number of
       window hits belonging to it */}                                           
2005                                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (int)id\_win\_hits.size(); i++ )
2006                                         \{
2007                                             \_id = (int)id\_win\_hits[i].\textcolor{keywordtype}{id};
2008 
2009                                             num\_hits = positions\_tbl[\_id].size;
2010 
2011                                             \textcolor{comment}{/* loop through every position of id */}
2012                                             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < num\_hits; j++ )
2013                                             \{
2014                                                 seq = (\textcolor{keywordtype}{unsigned} int)(positions\_tbl[\_id].arr[j].seq);        
2015                                     
2016                                                 most\_frequent\_seq[seq].first++;
2017                                             \}                                           
2018                                         \}
2019 
2020                                         \textcolor{comment}{/* sort the highest scoring sequences to the head of the array */}
2021                                         sort(most\_frequent\_seq.begin(), most\_frequent\_seq.end(), 
      \hyperlink{paralleltraversal_8cpp_a1f28ab873c1f9f30e5359a263ac7b780}{descending\_s});
2022 
2023                                         \textcolor{comment}{/* default: search all sequences */}
2024                                         \textcolor{keywordflow}{if} ( (\hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} < 0) && (
      \hyperlink{main_8cpp_ae58af383c31c36bdc039b24ea2730b83}{blastout\_gv} || \hyperlink{main_8cpp_a2cd647a5df32ab9cad67cb8a452d7aec}{samout\_gv}) )
2025                                         \{
2026 \textcolor{preprocessor}{                                                #pragma omp critical}
2027 \textcolor{preprocessor}{}                                                \{
2028                                                     \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} = numseq\_part[part];
2029                                                 \}
2030                                         \}
2031 
2032                                         \textcolor{comment}{/* user defined: search best\_gv sequences */}
2033                                         \textcolor{keywordtype}{int} bestx = \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv};
2034 
2035                                         \textcolor{comment}{/* STEP 3: for each reference sequence candidate (starting from
       highest scoring) */}
2036                                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{int} k = 0; k < numseq\_part[part]; k++ )
2037                                         \{
2038                                             max\_occur = most\_frequent\_seq[k].first; 
2039                                             max\_seq = most\_frequent\_seq[k].second;
2040 
2041                                             \textcolor{comment}{/* update number of sequences remaining to check */}
2042                                             \textcolor{keywordflow}{if} ( aligned && (\hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} > 0) ) bestx--;
2043 
2044                                             \textcolor{comment}{/* not enough window hits, try to collect more hits or go to
       next read */}
2045                                             \textcolor{keywordflow}{if} ( max\_occur < \hyperlink{main_8cpp_a68cd0d4a5619a828337cbd1c4d173ab2}{seed\_hits\_gv} )
2046                                                 \textcolor{keywordflow}{break};
2047         
2048                                             \textcolor{comment}{/* stop after the first alignment (--fastx or --feeling-lucky
       output only) */}
2049                                             \textcolor{keywordflow}{if} ( aligned && (\hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} < 0) && !
      \hyperlink{main_8cpp_ab00aebe854a2f74ea21e7cf433eb12ec}{all\_gv} ) 
2050                                                 \textcolor{keywordflow}{break};
2051 
2052                                             \textcolor{comment}{/* stop after best\_gv alignments */}
2053                                             \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} > 0 )
2054                                             \{
2055                                                 \textcolor{comment}{/* this reference sequence has less window hits than the
       previous, collect more hits or go to next read */}
2056                                                 \textcolor{keywordflow}{if} ( k > 0 )
2057                                                     \textcolor{keywordflow}{if} ( max\_occur < most\_frequent\_seq[k-1].first )
2058                                                         \textcolor{keywordflow}{if} ( bestx < 1 )
2059                                                             \textcolor{keywordflow}{break};
2060                                             \}
2061 
2062 
2063                                     
2064                                             \textcolor{comment}{/* STEP 4: collect all the genome positions belonging to the
       reference candidate from}
2065 \textcolor{comment}{                             the table of positions computed during indexing */}
2066                                             vector<mypair> hits\_on\_genome;
2067                                             \textcolor{keywordtype}{int} count = 0;
2068 
2069                                             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (int)id\_win\_hits.size(); i++ )
2070                                             \{
2071                                                 \_id = (int)id\_win\_hits[i].\textcolor{keywordtype}{id};
2072 
2073                                                 num\_hits = positions\_tbl[\_id].size;
2074 
2075                                                 \textcolor{comment}{/* loop through every position of id */}
2076                                                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < num\_hits; j++ )
2077                                                 \{
2078                                                     \textcolor{keywordflow}{if} ( positions\_tbl[\_id].arr[j].seq == max\_seq )
2079                                                     \{   
2080                                                         count++;
2081 
2082                                                         hits\_on\_genome.push\_back( mypair(positions\_tbl[\_id]
      .arr[j].pos, id\_win\_hits[i].win) );
2083                                                     \}
2084                                                 \}
2085                                             \}
2086 
2087                                             \textcolor{comment}{/* sort the positions on genome in ascending order */}
2088                                             sort(hits\_on\_genome.begin(), hits\_on\_genome.end(), 
      \hyperlink{paralleltraversal_8cpp_a30794deb1472194e2edd74e47b3f6a2f}{compare});
2089 
2090                                             \textcolor{comment}{/* iterate over the set of hits, output windows of length ==
       read which have }
2091 \textcolor{comment}{                                                 at least ratio hits */}
2092                                             vector<mypair>::iterator it3 = hits\_on\_genome.begin();
2093                                             deque<pair<unsigned int,int> > vi\_read;
2094                                             deque<pair<unsigned int,int> >::iterator deq;
2095 
2096                                             \textcolor{comment}{/* STEP 5: run a sliding window of read's length across the
       genome, and search for}
2097 \textcolor{comment}{                          windows with enough 18-mer hits */}
2098                                             \textcolor{keywordtype}{int} lcs\_ref\_start = 0;
2099                                             \textcolor{keywordtype}{int} lcs\_que\_start = 0;
2100 
2101                                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} begin = it3->first;
2102 
2103                                             \textcolor{keywordflow}{while} ( it3 != hits\_on\_genome.end() )
2104                                             \{
2105                                                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} stop = begin + readlen - 
      \hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv} + 1;
2106                                                 \textcolor{keywordtype}{bool} push = \textcolor{keyword}{false};
2107 
2108                                                 \textcolor{keywordflow}{while} ( it3 != hits\_on\_genome.end() && it3->first <= stop )
2109                                                 \{
2110                                                     vi\_read.push\_back(*it3);
2111                                                     push = \textcolor{keyword}{true};
2112                                                     it3++;
2113                                                 \}
2114                                                 \textcolor{comment}{/* a new window hit was not pushed back, pop queue until
       new window can be pushed back */}
2115                                                 \textcolor{keywordflow}{if} ( !push && aligned )
2116                                                 \{
2117                                                     \textcolor{keywordflow}{goto} pop;
2118                                                 \}
2119                                                 \textcolor{keywordflow}{else}
2120                                                     aligned = \textcolor{keyword}{false};
2121 
2122                                                 \textcolor{comment}{/* enough windows at this position on genome to search for
       LCS */}
2123                                                 \textcolor{keywordflow}{if} ( (\textcolor{keywordtype}{int})vi\_read.size() >= 
      \hyperlink{main_8cpp_a68cd0d4a5619a828337cbd1c4d173ab2}{seed\_hits\_gv} )
2124                                                 \{
2125                                                     vector<int> list;
2126                                                     \hyperlink{paralleltraversal_8cpp_ae10071d85a50b60e3da9a5182dde4b39}{find\_lis}(vi\_read, list, readn);
2127 
2128                                                     \textcolor{comment}{/* LCS long enough to perform Smith-Waterman alignment 
      */}
2129                                                     \textcolor{keywordflow}{if} ( (\textcolor{keywordtype}{int})list.size() >= 
      \hyperlink{main_8cpp_a68cd0d4a5619a828337cbd1c4d173ab2}{seed\_hits\_gv} )
2130                                                     \{
2131                                                         lcs\_ref\_start = vi\_read[list[0]].first;
2132                                                         lcs\_que\_start = vi\_read[list[0]].second;
2133 
2134                                                         \textcolor{comment}{/* reference string */}
2135                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} head = 0;
2136                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} tail = 0;
2137                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} align\_ref\_start = 0;
2138                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} align\_que\_start = 0;   
2139                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} align\_length = 0;
2140                                                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} reflen = reference\_seq\_len[(int)
      max\_seq];
2141                                                         \textcolor{keywordtype}{int} edges = 0;
2142                                                         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a44190260369f5270c2a9a16785f81599}{as\_percent\_gv} )
2143                                                             edges = (((double)
      \hyperlink{main_8cpp_ae1fb1584f4110e0fcd92992a0c9f3de2}{edges\_gv}/100.0)*readlen);
2144                                                         \textcolor{keywordflow}{else}
2145                                                             edges = \hyperlink{main_8cpp_ae1fb1584f4110e0fcd92992a0c9f3de2}{edges\_gv};
2146 
2147                                                         \textcolor{comment}{/* part of the read hangs off the beginning of the
       reference seq }
2148 \textcolor{comment}{                                           ref |-----------------------------------|}
2149 \textcolor{comment}{                                    que |-------------------|}
2150 \textcolor{comment}{                                                 LCS |-----|}
2151 \textcolor{comment}{                                                        */}
2152                                                         \textcolor{keywordflow}{if} ( lcs\_ref\_start < lcs\_que\_start )    
2153                                                         \{
2154                                                             align\_ref\_start = 0;
2155                                                             align\_que\_start = lcs\_que\_start - lcs\_ref\_start
      ;
2156                                                             head = 0;
2157                                                             tail = reflen - align\_ref\_start - readlen;
2158                                                             tail > (edges-1) ? tail = edges : tail;
2159                                                             align\_length = readlen+head+tail-
      align\_que\_start;
2160                                                         \}
2161                                                         \textcolor{keywordflow}{else}
2162                                                         \{
2163                                                             align\_ref\_start = lcs\_ref\_start - lcs\_que\_start
      ;
2164                                                             align\_que\_start = 0;
2165                                                             align\_ref\_start > (edges-1) ? head = edges : 
      head;
2166                                                         
2167                                                             \textcolor{comment}{/* part of the read hangs off the end of the
       reference seq }
2168 \textcolor{comment}{                                                 ref |-----------------------------------|}
2169 \textcolor{comment}{                                                                           que |-------------------|}
2170 \textcolor{comment}{                                                                              LCS |-----|}
2171 \textcolor{comment}{                                                            */}
2172                                                             \textcolor{keywordflow}{if} ( align\_ref\_start+readlen > reflen )
2173                                                             \{
2174                                                                 tail = 0;
2175                                                                 align\_length = reflen-align\_ref\_start-head;
2176                                                             \}
2177                                                             \textcolor{comment}{/* the reference seq fully covers the read }
2178 \textcolor{comment}{                                                 ref |-----------------------------------|}
2179 \textcolor{comment}{                                                             que |-------------------|}
2180 \textcolor{comment}{                                                                      LCS |-----|}
2181 \textcolor{comment}{                                                            */}
2182                                                             \textcolor{keywordflow}{else}
2183                                                             \{
2184                                                                 tail = reflen - align\_ref\_start - readlen;
2185                                                                 tail > (edges-1) ? tail = edges : tail;
2186                                                                 align\_length = readlen+head+tail;
2187                                                             \}
2188                                                         \}
2189     
2190                             s\_profile* profile = 0;
2191                                                         profile = \hyperlink{ssw_8c_afb7b0d0e5dfca925b8d0679edd9fed00}{ssw\_init}((int8\_t*)(myread+
      align\_que\_start), (align\_length-head-tail), mat, 4, 2);
2192                                                         s\_align* result = 0;
2193 
2194                                                         result = \hyperlink{ssw_8c_a5ab13aa021d7fc8e19cc9293bc7cea61}{ssw\_align}( profile, (int8\_t*)
      reference\_seq[(2*(\textcolor{keywordtype}{int})max\_seq)+1]+align\_ref\_start-head,align\_length, gap\_open, gap\_extension, 1, 0, 0, 0);
2195 
2196                                                         \textcolor{keywordtype}{double} evalue\_score = 0.0; 
2197                                                                                                 
2198                                                         \textcolor{keywordflow}{if} ( result != 0 ) 
2199                                                         \{
2200                                                             \textcolor{comment}{//evalue\_score =
       (double)K\_gv*full\_ref\_gv*full\_read\_gv*pow(EXP,(-lambda\_gv*result->score1));}
2201 
2202                                                             \textcolor{comment}{//if ( evalue\_score < evalue )}
2203                                                             \textcolor{keywordflow}{if} ( result->score1 > 
      \hyperlink{paralleltraversal_8cpp_a322857d371001fcdc993be8b69d49d01}{minimal\_score\_gv} )
2204                                                             aligned = \textcolor{keyword}{true};
2205                                                         \}
2206 
2207                                                         \textcolor{comment}{/* STEP 8: alignment succeeded, output (--all) or
       store (--best) the alignment and go to next alignment */}
2208                                                         \textcolor{keywordflow}{if} ( aligned )
2209                                                         \{
2210                                                             \textcolor{comment}{/* set bit to true for this read */}
2211 \textcolor{preprocessor}{                                                            #pragma omp critical}
2212 \textcolor{preprocessor}{}                                                            \{
2213                                                                 \textcolor{keywordflow}{if} ( !read\_hits[(\textcolor{keywordtype}{int})((readn-1)>>1)] )
2214                                                                 \{
2215                                                                     read\_hits[(int)((readn-1)>>1)].flip();  
2216                                                                     total\_reads\_mapped++;
2217                                                                 \}
2218                                                             \}
2219 
2220 
2221                                                             \textcolor{comment}{/* do not output alignment, just filter
       (--fastx) */}
2222                                                             \textcolor{keywordflow}{if} ( (!\hyperlink{main_8cpp_ab00aebe854a2f74ea21e7cf433eb12ec}{all\_gv} && (
      \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} < 0)) )
2223                                                             \{   
2224                                                                 search = \textcolor{keyword}{false};
2225                                                                 \hyperlink{ssw_8c_ac8dd4df865a5364ae821155a8f6b8264}{align\_destroy}(result);
2226                                                                 \hyperlink{ssw_8c_a243857b244ba496a0558a68f1f2c05e4}{init\_destroy}(profile);
2227                                                                 \textcolor{keywordflow}{break};
2228                                                             \}   
2229 
2230 
2231 
2232                                                             \textcolor{comment}{/* output (sam or blast-like) or update
       alignment information */}
2233                                                             \textcolor{keywordtype}{bool} strand = 0;
2234                                                             \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_aeb939919c5625c41da3e53c1deb325c3}{forward\_gv} ) strand = 0;
2235                                                             \textcolor{keywordflow}{else} 
2236                                                                 strand = 1;
2237 
2238                                                             \textcolor{keywordtype}{char}* read\_qual = NULL;
2239                                                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'@'} )   
2240                                                                 read\_qual = reads[readn]+readlen+1;
2241 
2242                                                             \textcolor{comment}{/* add the offset calculated by the LCS (from
       the beginning of the sequence) to the}
2243 \textcolor{comment}{                                   offset computed by SW alignment */}
2244                                                             result->ref\_begin1 += (align\_ref\_start-head);
2245                                                             result->ref\_end1 += (align\_ref\_start-head);
2246                                                             result->read\_begin1 += align\_que\_start;
2247                                                             result->read\_end1 += align\_que\_start;
2248 
2249                                                             \textcolor{comment}{/* update best alignment */}
2250                                                             \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} > 0 && 
      \hyperlink{main_8cpp_ab00aebe854a2f74ea21e7cf433eb12ec}{all\_gv})
2251                                                             \{
2252 \textcolor{preprocessor}{                                                                #pragma omp critical}
2253 \textcolor{preprocessor}{}                                                                \{
2254                                                                     map<unsigned int, s\_align>::iterator 
      alignment = read\_hits\_align\_info.find(readn);
2255 
2256                                                                     \textcolor{comment}{/* an alignment for this read already
       exists */}
2257                                                                     \textcolor{keywordflow}{if} ( alignment != read\_hits\_align\_info.
      end() )
2258                                                                     \{
2259                                                                         \textcolor{keywordflow}{if} ( (result->score1) > alignment->
      second.score1 )
2260                                                                         \{
2261                                                                             result->ref\_seq = max\_seq;
2262                                                                             result->part = part;
2263                                                                             result->strand = strand;
2264                                       free(alignment->second.cigar); \textcolor{comment}{//free the old cigar}
2265                                                                             alignment->second.cigar = NULL;
2266                                                                             memcpy(&(alignment->second),
      result,\textcolor{keyword}{sizeof}(s\_align));
2267                                                                             free(result); \textcolor{comment}{//free result,
       except the cigar   }
2268                                                                             result = NULL;
2269                                                                         \} 
2270                                                                     \}
2271                                                                     \textcolor{comment}{/* an alignment for this read doesn't
       exist, add the first alignment */}
2272                                                                     \textcolor{keywordflow}{else}    
2273                                                                     \{
2274                                                                         result->ref\_seq = max\_seq;
2275                                                                         result->part = part;
2276                                                                         result->strand = strand;
2277                                                                         read\_hits\_align\_info.insert( 
      pair<unsigned int, s\_align>(readn,*result) );
2278                                                                         free(result); \textcolor{comment}{//free result, except
       the cigar}
2279                                                                         result = NULL;
2280                                                                     \}
2281                                                                 \}\textcolor{comment}{//~pragma omp critical }
2282 
2283                                                             \}
2284                                                             \textcolor{comment}{/* output alignment (only accessed if --all
       option was chosen) */}
2285                                                             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_ab00aebe854a2f74ea21e7cf433eb12ec}{all\_gv} ) 
2286                                                             \{
2287 \textcolor{preprocessor}{                                                                #pragma omp critical}
2288 \textcolor{preprocessor}{}                                                                \{
2289                                                                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bitscore = (\textcolor{keywordtype}{unsigned} int)(
      (\textcolor{keywordtype}{float})(\hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\_gv}*(result->score1) - log(\hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}))/(\textcolor{keywordtype}{float})log(2));
2290                                                             
2291                                                                     \textcolor{keywordflow}{if} ( 
      \hyperlink{main_8cpp_ae58af383c31c36bdc039b24ea2730b83}{blastout\_gv} )
2292                                                                     \{
2293                                                                         
      \hyperlink{ssw_8c_a3e27d484ae00abc8e9b6e9a7728df093}{ssw\_write} (acceptedstrings\_blast, \textcolor{comment}{//blast output file}
2294                                                                                                 result, \textcolor{comment}{//
      SW alignment cigar}
2295                                                                                                 reads[readn
      -1]+1, \textcolor{comment}{//read name}
2296                                                                                                 myread, \textcolor{comment}{//
      read sequence}
2297                                                                                                 read\_qual, \textcolor{comment}{
      //read quality}
2298                                                                                                 
      reference\_seq[(2*(\textcolor{keywordtype}{int})max\_seq)]+1, \textcolor{comment}{//reference name }
2299                                                                                                 
      reference\_seq[(2*(\textcolor{keywordtype}{int})max\_seq)+1], \textcolor{comment}{//reference sequence}
2300                                                                                                 
      evalue\_score, \textcolor{comment}{//e-value score}
2301                                                                                                 bitscore,
2302                                                                                                 strand, \textcolor{comment}{//
      forward or reverse complement}
2303                                                                                                 1); \textcolor{comment}{// 1 if
       blast output, 0 if sam output}
2304                                                                     \}
2305 
2306                                                                     \textcolor{keywordflow}{if} ( 
      \hyperlink{main_8cpp_a2cd647a5df32ab9cad67cb8a452d7aec}{samout\_gv} )
2307                                                                     \{
2308                                                                         
      \hyperlink{ssw_8c_a3e27d484ae00abc8e9b6e9a7728df093}{ssw\_write} (acceptedstrings\_sam, \textcolor{comment}{//sam output file}
2309                                                                                                 result, \textcolor{comment}{//
      SW alignment cigar}
2310                                                                                                 reads[readn
      -1]+1, \textcolor{comment}{//read name}
2311                                                                                                 myread, \textcolor{comment}{//
      read sequence}
2312                                                                                                 read\_qual, \textcolor{comment}{
      //read quality}
2313                                                                                                 
      reference\_seq[(2*(\textcolor{keywordtype}{int})max\_seq)]+1, \textcolor{comment}{//reference name }
2314                                                                                                 
      reference\_seq[(2*(\textcolor{keywordtype}{int})max\_seq)+1], \textcolor{comment}{//reference sequence}
2315                                                                                                 
      evalue\_score, \textcolor{comment}{//e-value score (only for blast)}
2316                                                                                                 bitscore,
2317                                                                                                 strand, \textcolor{comment}{//
      forward or reverse complement}
2318                                                                                                 0); \textcolor{comment}{// 1 if
       blast output, 0 if sam output}
2319                                                                     \}
2320                                                                 \}\textcolor{comment}{//~pragma omp critical}
2321                                                             \}\textcolor{comment}{//~if output all alignments}
2322 
2323 
2324                                                             \textcolor{comment}{/* stop search after first alignment reaching
       E-value threshold (--feeling\_lucky) */}
2325                                                             \textcolor{keywordflow}{if} ( 
      \hyperlink{main_8cpp_ad0d18567de4cd040dc8fd7c313a00563}{feeling\_lucky\_gv} )
2326                                                             \{   
2327                                                                 search = \textcolor{keyword}{false};
2328                                                                 \hyperlink{ssw_8c_a243857b244ba496a0558a68f1f2c05e4}{init\_destroy}(profile);
2329                                                                 \textcolor{keywordflow}{break};
2330                                                             \}   
2331     
2332                                                             \textcolor{comment}{/* continue to next alignment (do not need to
       collect more seeds using another pass) */}
2333                                                             search = \textcolor{keyword}{false};
2334 
2335                                                         \}\textcolor{comment}{//~if read aligned}
2336 
2337                                                         \textcolor{keywordflow}{if} ( result != 0 )  
2338                                                             \hyperlink{ssw_8c_ac8dd4df865a5364ae821155a8f6b8264}{align\_destroy}(result); 
2339                                                       \textcolor{keywordflow}{if} ( profile != 0 )
2340                                                             \hyperlink{ssw_8c_a243857b244ba496a0558a68f1f2c05e4}{init\_destroy}(profile);
2341 
2342                                                     \}\textcolor{comment}{//~if LCS long enough}
2343                                                 \}\textcolor{comment}{//~if enough window hits}
2344 
2345                                                 pop:
2346 
2347                                                 \textcolor{comment}{/* get the next candidate reference position */}
2348                                                 \textcolor{keywordflow}{if} ( !vi\_read.empty() )
2349                             vi\_read.pop\_front();
2350 
2351                                                 \textcolor{keywordflow}{if} ( vi\_read.empty() )  
2352                                                 \{
2353                                                     \textcolor{keywordflow}{if} ( it3 != hits\_on\_genome.end() )
2354                                                         begin = it3->first;
2355                                                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{break};
2356                                                 \}
2357                                                 \textcolor{keywordflow}{else}
2358                                                 \{
2359                                                     begin = (vi\_read.front()).first;
2360                                                 \}
2361                                             \}\textcolor{comment}{//~for all reference sequence length}
2362 
2363                                         \}\textcolor{comment}{//~for all of the reference sequence candidates}
2364 
2365                                     \}\textcolor{comment}{//if ( readhitf || readhitr > ratio )}
2366 
2367                                     \textcolor{comment}{/* the read was not accepted at current window skip length, decrease
       the window skip length */}
2368                                     \textcolor{keywordflow}{if} ( search )
2369                                     \{   
2370                                         \textcolor{keywordflow}{if} ( windowshift == \hyperlink{main_8cpp_a207b71e113d2c4b5c5b4cc13640c1fa1}{skiplength\_1} )
2371                                             windowshift = \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2};
2372                                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( windowshift == \hyperlink{main_8cpp_ab445aad072bdf51826cd7a3fae49616e}{skiplength\_2} ) 
2373                                             windowshift = \hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3};
2374                                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( windowshift == \hyperlink{main_8cpp_ae1700b6bd6995013449fc790ebe8395e}{skiplength\_3} )
2375                                             search = \textcolor{keyword}{false};
2376                                         \textcolor{keywordflow}{else}
2377                                         \{
2378                                             fprintf(stderr,\textcolor{stringliteral}{"\(\backslash\)n  ERROR: Incorrect start index for traversal
       (paralleltraversal.cpp)\(\backslash\)n"});
2379                                             exit(EXIT\_FAILURE);
2380                                         \}
2381                                     \}
2382 
2383                                     \textcolor{comment}{/* do not offset last window on read */}
2384                                     \textcolor{keywordflow}{break};
2385                                 \}\textcolor{comment}{//~( win\_num == NUMWIN-1 )}
2386 
2387                                 read\_index+=windowshift;
2388 
2389                             \}\textcolor{comment}{//~for (each window) }
2390 
2391                         \textcolor{comment}{//~while all three window skip lengths have not been tested, or a match was found}
2392                       \} \textcolor{keywordflow}{while} ( search );
2393 
2394                     \}\textcolor{comment}{//~for (each read)}
2395 
2396                 \textcolor{comment}{/* search the reverse strand (default) */}
2397                 \hyperlink{main_8cpp_aeb939919c5625c41da3e53c1deb325c3}{forward\_gv} = \textcolor{keyword}{false};
2398 
2399             \}\textcolor{comment}{//for forward and/or reverse strands}
2400             TIME(f);
2401             eprintf(\textcolor{stringliteral}{" done                     [%.2f sec]\(\backslash\)n"}, (f-s) );
2402 
2403             eprintf(\textcolor{stringliteral}{"  Freeing index ... "});
2404 
2405         
2406             TIME(s);
2407 \textcolor{preprocessor}{            #pragma omp master}
2408 \textcolor{preprocessor}{}            \{
2409                 \textcolor{comment}{/* free the positions table */}
2410                 \textcolor{keywordflow}{if} ( positions\_tbl != NULL )
2411                 \{
2412                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (int)number\_elements; i++ )
2413                     \{
2414                         \textcolor{keywordflow}{if} ( positions\_tbl[i].arr != NULL )
2415                         \{
2416                             \textcolor{keyword}{delete} [] positions\_tbl[i].arr;
2417                             positions\_tbl[i].arr = NULL;
2418                         \}
2419                     \}
2420                     \textcolor{keyword}{delete} [] positions\_tbl;
2421                     positions\_tbl = NULL;
2422                 \}
2423 
2424                 \textcolor{comment}{/* free reference sequences loaded into memory */}
2425                 \textcolor{keywordflow}{if} ( buffer != NULL )
2426                 \{
2427                     \textcolor{keyword}{delete} [] buffer;
2428                     buffer = NULL;
2429                 \}
2430                 \textcolor{keywordflow}{if} ( reference\_seq != NULL )
2431                 \{
2432                     \textcolor{keyword}{delete} [] reference\_seq;
2433                     reference\_seq = NULL;
2434                 \}
2435                 \textcolor{keywordflow}{if} ( reference\_seq\_len != NULL )
2436                 \{
2437                     \textcolor{keyword}{delete} [] reference\_seq\_len;
2438                     reference\_seq\_len = NULL;
2439                 \}
2440 
2441                 \textcolor{comment}{/* free 9-mer look-up tables and mini-burst tries */}
2442                 \textcolor{keywordflow}{if} ( lookup\_tbl != NULL )
2443                 \{
2444                     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 0; i < (1<<\hyperlink{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{lnwin\_gv}); i++ )
2445                     \{
2446                         \textcolor{keywordflow}{if} (lookup\_tbl[i].trie\_F != NULL )
2447                         \{
2448                             \textcolor{keyword}{delete} [] lookup\_tbl[i].trie\_F;
2449                             lookup\_tbl[i].trie\_F = NULL;
2450                             lookup\_tbl[i].trie\_R = NULL;
2451                         \}
2452                         \textcolor{keywordflow}{if} ( lookup\_tbl[i].trie\_R != NULL )
2453                         \{
2454                             \textcolor{keyword}{delete} [] lookup\_tbl[i].trie\_R;
2455                             lookup\_tbl[i].trie\_R = NULL;
2456                         \}
2457                     \}
2458                     \textcolor{keyword}{delete} [] lookup\_tbl;
2459                     lookup\_tbl = NULL;
2460                 \}
2461             \}
2462             TIME(f);
2463 
2464             eprintf(\textcolor{stringliteral}{"  done ... [%.2f sec]\(\backslash\)n"}, (f-s));
2465 
2466             \textcolor{comment}{/* increment the index part to next file */}
2467             prt\_str.str(\textcolor{stringliteral}{""});
2468             prt\_str << (part+1);
2469             part\_str = prt\_str.str();
2470 
2471     \}\textcolor{comment}{//~for all parts of the index}
2472 
2473             
2474         eprintf(\textcolor{stringliteral}{"    Total number of reads mapped (in this file section):  %d\(\backslash\)n"},total\_reads\_mapped);
2475 
2476       \textcolor{comment}{/* output all matched & nonmatched reads */}
2477       TIME(s);
2478 
2479 
2480         \textcolor{comment}{/* output best alignment per read */}
2481         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a6dda06c368c8302c19e51c2fdcd9b1d9}{best\_gv} > 0 )
2482         \{
2483             \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i = 0; i < num\_index\_parts; i++ )
2484             \{
2485                 \textcolor{comment}{/* block of memory to hold all ids + reference sequences */}
2486                 \textcolor{keywordtype}{char}* buffer = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[(seq\_part\_size[i]+1)]();
2487                 \textcolor{keywordflow}{if} ( buffer == NULL )
2488                 \{
2489                     fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for reference sequence buffer
       (paralleltraversal.cpp)\(\backslash\)n"});
2490                     exit(EXIT\_FAILURE);
2491                 \}
2492 
2493                 \textcolor{comment}{/* pointer to the start of every sequence in the buffer */}
2494                 \textcolor{keywordtype}{char}** reference\_seq = \textcolor{keyword}{new} \textcolor{keywordtype}{char}*[(numseq\_part[i]<<1)](); 
2495                 \textcolor{keywordflow}{if} ( reference\_seq == NULL )
2496                 \{
2497                     fprintf(stderr,\textcolor{stringliteral}{"  ERROR: could not allocate memory for reference\_seq
       (paralleltraversal.cpp)\(\backslash\)n"});
2498                     exit(EXIT\_FAILURE);
2499                 \}
2500 
2501                 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}* reference\_seq\_len = NULL;
2502 
2503                 \hyperlink{paralleltraversal_8cpp_a2790ed8252fe8ba0732735cce725c4bc}{load\_ref}(ptr\_dbfile,buffer,reference\_seq,reference\_seq\_len,seq\_part\_size[i],
      numseq\_part[i],start\_part[i],0);
2504 
2505 \textcolor{preprocessor}{                #pragma omp parallel num\_threads(numcpu\_gv)}
2506 \textcolor{preprocessor}{}                \{
2507 \textcolor{preprocessor}{                    #pragma omp for}
2508 \textcolor{preprocessor}{}                    \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 1; j < (int)strs; j+=2 )
2509                     \{
2510                         \textcolor{comment}{/* read matched best to this index part, align & output */}
2511                         map<unsigned int,s\_align>::iterator alignment = read\_hits\_align\_info.find(j);
2512 
2513                         \textcolor{comment}{/* this read does not have any alignment */}
2514                         \textcolor{keywordflow}{if} ( alignment == read\_hits\_align\_info.end() )
2515                             \textcolor{keywordflow}{continue};
2516                         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ( (alignment->second.part == i) && (alignment->second.score1 > 0 ) )
2517                         \{
2518                             \textcolor{comment}{/* read on integer alphabet \{0,1,2,3\} */}
2519                             \textcolor{keywordtype}{char} myread[READLEN];
2520                             \textcolor{keywordtype}{char}* str = reads[j];
2521                             \textcolor{keywordtype}{char}* ptr = &myread[0]; 
2522 
2523                             \textcolor{comment}{/* length of read */}
2524                             \textcolor{keywordtype}{int} readlen = 0;
2525 
2526                             \textcolor{comment}{/* change the read into an integer alphabet -- FASTA */}
2527                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2528                             \{
2529                                 \textcolor{keywordflow}{while} ( *str != \textcolor{charliteral}{'\(\backslash\)0'} && *str != \textcolor{charliteral}{'>'} )
2530                           \{
2531                                     \textcolor{keywordflow}{if} ( *str != \textcolor{charliteral}{'\(\backslash\)n'} ) 
2532                                     \{
2533                                     *ptr++ = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[(int)*str];
2534                                     readlen++;
2535                                     \}
2536                                     str++;                      
2537                           \}
2538                             \}
2539                             \textcolor{comment}{/* change the read into an integer alphabet -- FASTQ */}
2540                             \textcolor{keywordflow}{else}
2541                             \{
2542                                 \textcolor{keywordflow}{while} ( *str != \textcolor{charliteral}{'\(\backslash\)n'} )
2543                           \{
2544                                     *ptr++ = \hyperlink{indexdb_8cpp_abbfa59b376110cc05e9a652602a00acc}{map\_nt}[(int)*str++];
2545                                 readlen++;
2546                           \}
2547                             \}
2548 
2549                             \textcolor{comment}{/* create the reverse strand */}
2550                             \textcolor{keywordflow}{if} ( alignment->second.strand )
2551                             \{
2552                                 \textcolor{keywordtype}{char} myread\_rc[READLEN];
2553                                 \textcolor{comment}{/* faster than xor algorithm */}
2554                                 \textcolor{keywordtype}{char}* revcomp = &myread[readlen-1];
2555 
2556                                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < readlen; j++ )
2557                                 myread\_rc[j] = \hyperlink{paralleltraversal_8cpp_adf8e093429055846312e4c3c3d564c1f}{complement}[(\textcolor{keywordtype}{int})*revcomp--];
2558 
2559                                 memcpy(&myread[0],&myread\_rc[0],READLEN);
2560                             \}\textcolor{comment}{//~if (REVERSE)}
2561 
2562 
2563                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} ref\_seq = alignment->second.ref\_seq;
2564                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bitscore = (\textcolor{keywordtype}{unsigned} int)((\textcolor{keywordtype}{float})(
      \hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\_gv}*(alignment->second.score1) - log(\hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}))/(\textcolor{keywordtype}{float})log(2));
2565                             \textcolor{keywordtype}{double} evalue\_score = (double)\hyperlink{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{K\_gv}*\hyperlink{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{full\_ref\_gv}*
      \hyperlink{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{full\_read\_gv}*pow(\hyperlink{paralleltraversal_8cpp_a84db90500a1f9527c04e28817d9f60a1}{EXP},(-\hyperlink{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{lambda\_gv}*alignment->second.score1));
2566 
2567                             \textcolor{keywordtype}{char}* read\_qual = NULL;
2568                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'@'} )   
2569                                 read\_qual = reads[j]+readlen+1;
2570 
2571 
2572 \textcolor{preprocessor}{                            #pragma omp critical}
2573 \textcolor{preprocessor}{}                            \{
2574                                 \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_ae58af383c31c36bdc039b24ea2730b83}{blastout\_gv} )
2575                                 \{
2576                                     \hyperlink{ssw_8c_a3e27d484ae00abc8e9b6e9a7728df093}{ssw\_write} (acceptedstrings\_blast, \textcolor{comment}{//blast output file}
2577                                                             &(alignment->second), \textcolor{comment}{//SW alignment cigar}
2578                                                             reads[j-1]+1,
2579                                                             myread, \textcolor{comment}{//read sequence}
2580                                                             read\_qual, \textcolor{comment}{//read quality}
2581                                                             reference\_seq[(2*(\textcolor{keywordtype}{int})ref\_seq)]+1, \textcolor{comment}{//reference
       name }
2582                                                             reference\_seq[(2*(\textcolor{keywordtype}{int})ref\_seq)+1], \textcolor{comment}{//reference
       sequence}
2583                                                             evalue\_score, \textcolor{comment}{//e-value score}
2584                                                             bitscore,
2585                                                             alignment->second.strand,
2586                                                             1); \textcolor{comment}{// 1 if blast output, 0 if sam output}
2587                                 \}
2588 
2589                                 \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a2cd647a5df32ab9cad67cb8a452d7aec}{samout\_gv} )
2590                                 \{
2591                                     \hyperlink{ssw_8c_a3e27d484ae00abc8e9b6e9a7728df093}{ssw\_write} (acceptedstrings\_sam, \textcolor{comment}{//sam output file}
2592                                                             &(alignment->second), \textcolor{comment}{//SW alignment cigar}
2593                                                             reads[j-1]+1,
2594                                                             myread, \textcolor{comment}{//read sequence}
2595                                                             read\_qual, \textcolor{comment}{//read quality}
2596                                                             reference\_seq[(2*(\textcolor{keywordtype}{int})ref\_seq)]+1, \textcolor{comment}{//reference
       name }
2597                                                             reference\_seq[(2*(\textcolor{keywordtype}{int})ref\_seq)+1], \textcolor{comment}{//reference
       sequence}
2598                                                             evalue\_score, \textcolor{comment}{//e-value score (only for blast)}
2599                                                             bitscore,
2600                                                             alignment->second.strand,
2601                                                             0); \textcolor{comment}{// 1 if blast output, 0 if sam output}
2602                                 \}
2603 
2604                                 free(alignment->second.cigar);
2605                                 alignment->second.cigar = NULL;
2606 
2607                             \}\textcolor{comment}{//~pragma omp critical}
2608 
2609                         \}\textcolor{comment}{//~if read hits this index part}
2610                     \}\textcolor{comment}{//~for all the reads}
2611                 \}\textcolor{comment}{//~pragma omp parallel}
2612 
2613                 \textcolor{keywordflow}{if} ( buffer != NULL )
2614                 \{
2615                     \textcolor{keyword}{delete} [] buffer;
2616                     buffer = NULL;
2617                 \}
2618                 \textcolor{keywordflow}{if} ( reference\_seq != NULL )    
2619                 \{   
2620                     \textcolor{keyword}{delete} [] reference\_seq;
2621                     reference\_seq = NULL;
2622                 \}
2623                 \textcolor{keywordflow}{if} ( reference\_seq\_len != NULL )
2624                 \{
2625                     \textcolor{keyword}{delete} [] reference\_seq\_len;
2626                     reference\_seq\_len = NULL;
2627                 \}
2628             \}
2629         
2630             read\_hits\_align\_info.clear();   
2631 
2632         \}\textcolor{comment}{// if ( best\_gv && (num\_index\_parts > 1) )}
2633 
2634         \textcolor{keyword}{delete} [] seq\_part\_size;
2635         seq\_part\_size = NULL;
2636         \textcolor{keyword}{delete} [] numseq\_part;
2637         numseq\_part = NULL;
2638         \textcolor{keyword}{delete} [] start\_part;
2639         start\_part = NULL;
2640 
2641         \textcolor{comment}{/* output accepted reads */}
2642         \textcolor{keywordflow}{if} ( ptr\_filetype\_ar != NULL && \hyperlink{main_8cpp_a10e5ea4d5132a75aa2fa4947c714d874}{fastxout\_gv} )
2643         \{
2644             acceptedreads.open ( acceptedstrings, ios::app );
2645 
2646             \textcolor{comment}{/* pair-ended reads */}
2647             \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_afc6382b7206ae052d18f155d348e35cd}{pairedin\_gv} || \hyperlink{main_8cpp_a257328da6707629142f6897fdef84c39}{pairedout\_gv} )
2648             \{
2649                 \textcolor{comment}{/* fastq line counter */}
2650                 \textcolor{keywordtype}{int} n\_count = 0;
2651 
2652                 \textcolor{comment}{/* loop through every read, output accepted reads */}
2653                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 1; i < (int)strs; i+=4 )
2654                 \{
2655                     \textcolor{keywordtype}{char}* thisread = reads[i-1]+1;
2656 
2657                     \textcolor{comment}{/* output both reads if both were accepted, or at least one was accepted and PAIREDIN
       == true */}
2658                     \textcolor{keywordtype}{int} read1 = (i-1)>>1;
2659 
2660                     \textcolor{keywordflow}{if} ( (read\_hits[read1] && read\_hits[read1+1]) 
2661                 || 
2662                (read\_hits[read1] || (read\_hits[read1+1] && \hyperlink{main_8cpp_afc6382b7206ae052d18f155d348e35cd}{pairedin\_gv})) )
2663                     \{
2664                         \textcolor{keywordflow}{if} ( acceptedreads.is\_open() )
2665                         \{
2666                             acceptedreads << filesig;
2667 
2668                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2669                             \{
2670                                 \textcolor{comment}{/* the first read */}
2671                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} )
2672                                     otherreads << (char)*thisread++;
2673 
2674                                 \textcolor{comment}{/* the '>' character */}
2675                                 otherreads << (char)*thisread++;
2676 
2677                                 \textcolor{comment}{/* the second read */}
2678                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} && *thisread != \textcolor{charliteral}{'\(\backslash\)0'} )
2679                                     otherreads << (char)*thisread++;
2680                             \}\textcolor{comment}{//~FASTA}
2681                             \textcolor{keywordflow}{else}
2682                             \{
2683                                 \textcolor{keywordflow}{while} ( n\_count < 8 )
2684                                 \{
2685                                     \textcolor{comment}{/* output only the tag */}
2686                                     acceptedreads << (char)*thisread;
2687                                     \textcolor{keywordflow}{if} ( *thisread == \textcolor{charliteral}{'\(\backslash\)0'} || *thisread++ == \textcolor{charliteral}{'\(\backslash\)n'} ) 
2688                                         n\_count++;
2689                                 \}
2690                                 n\_count = 0;
2691                             \}\textcolor{comment}{//~FASTQ}
2692                         \}
2693                     \}\textcolor{comment}{//~the read was accepted}
2694                 \}\textcolor{comment}{//~for all reads}
2695 
2696                 \textcolor{keywordflow}{if} ( acceptedreads.is\_open() )
2697                     acceptedreads.close();
2698             \}
2699             \textcolor{comment}{/* regular or pair-ended reads don't need to go into the same file */}
2700             \textcolor{keywordflow}{else}
2701             \{
2702                 \textcolor{comment}{/* fastq line counter */}
2703                 \textcolor{keywordtype}{int} n\_count = 0;
2704 
2705                 \textcolor{comment}{/* loop through every read, output accepted reads */}
2706                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 1; i < (int)strs; i+=2 )
2707                 \{
2708                     \textcolor{keywordtype}{char}* thisread = reads[i-1]+1;
2709 
2710                     \textcolor{keywordtype}{int} read1 = (i-1)>>1;
2711 
2712                     \textcolor{comment}{/* the read was accepted */}
2713                     \textcolor{keywordflow}{if} ( read\_hits[read1] )
2714                     \{
2715                         \textcolor{comment}{/* accepted reads file output */}
2716                         \textcolor{keywordflow}{if} ( acceptedreads.is\_open() )
2717                         \{
2718                             acceptedreads << filesig;
2719 
2720                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2721                             \{
2722                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} && *thisread != \textcolor{charliteral}{'\(\backslash\)0'} )
2723                                     acceptedreads << (char)*thisread++;
2724                             \}\textcolor{comment}{//~FASTA}
2725                             \textcolor{keywordflow}{else}
2726                             \{
2727                                 \textcolor{keywordflow}{while} ( n\_count < 4 )
2728                                 \{
2729                                     acceptedreads << (char)*thisread;
2730                                     \textcolor{keywordflow}{if} ( *thisread == \textcolor{charliteral}{'\(\backslash\)0'} || *thisread++ == \textcolor{charliteral}{'\(\backslash\)n'} ) 
2731                                         n\_count++;  
2732                                 \}
2733                                 n\_count = 0;
2734                             \}\textcolor{comment}{//~FASTQ}
2735                         \}
2736                     \}
2737                 \}
2738 
2739                 \textcolor{keywordflow}{if} ( acceptedreads.is\_open() )
2740                     acceptedreads.close();
2741             \}
2742 
2743         \}\textcolor{comment}{//~if ( ptr\_filetype\_ar != NULL )}
2744 
2745 
2746         \textcolor{comment}{/* output other reads */}
2747         \textcolor{keywordflow}{if} ( ptr\_filetype\_or != NULL && \hyperlink{main_8cpp_a10e5ea4d5132a75aa2fa4947c714d874}{fastxout\_gv} )
2748         \{
2749             otherreads.open( ptr\_filetype\_or, ios::app );
2750 
2751             \textcolor{comment}{/* fastq '\(\backslash\)n' counter */}
2752             \textcolor{keywordtype}{int} n\_count = 0;
2753 
2754             \textcolor{comment}{/* pair-ended reads */}
2755             \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_afc6382b7206ae052d18f155d348e35cd}{pairedin\_gv} || \hyperlink{main_8cpp_a257328da6707629142f6897fdef84c39}{pairedout\_gv} )   
2756             \{
2757                 \textcolor{comment}{/* loop through every pair, output non-accepted pairs */}
2758                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 1; i < (int)strs; i+=4 )
2759                 \{
2760                     \textcolor{keywordtype}{char}* thisread = reads[i-1]+1;
2761                     \textcolor{keywordtype}{int} read1 = (i-1)>>1;
2762 
2763                     \textcolor{comment}{/* output both reads if both were NOT accepted, or at least one was NOT accepted and
       pairedout\_gv == true */}
2764                     \textcolor{keywordflow}{if} ( (read\_hits[read1] && read\_hits[read1+1]) 
2765                                 ||
2766                              (read\_hits[read1] || (read\_hits[read1+1] && 
      \hyperlink{main_8cpp_a257328da6707629142f6897fdef84c39}{pairedout\_gv})) )
2767                     \{
2768                         \textcolor{comment}{/* accepted reads file output */}
2769                         \textcolor{keywordflow}{if} ( otherreads.is\_open() )
2770                         \{
2771                             otherreads << filesig;
2772 
2773                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2774                             \{
2775                                 \textcolor{comment}{/* the first read */}
2776                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} )
2777                                     otherreads << (char)*thisread++;    
2778                     
2779                                 otherreads << (char)*thisread++;
2780 
2781                                 \textcolor{comment}{/* the second read */}
2782                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} && *thisread != \textcolor{charliteral}{'\(\backslash\)0'} )
2783                                     otherreads << (char)*thisread++;
2784                             \}\textcolor{comment}{//~FASTA}
2785                             \textcolor{keywordflow}{else}
2786                             \{
2787                                 \textcolor{keywordflow}{while} ( n\_count < 8 )
2788                                 \{
2789                                     otherreads << (char)*thisread;
2790                                     \textcolor{keywordflow}{if} ( *thisread == \textcolor{charliteral}{'\(\backslash\)0'} || *thisread++ == \textcolor{charliteral}{'\(\backslash\)n'} ) 
2791                                         n\_count++;  
2792                                 \}
2793                                 n\_count = 0;
2794                             \}\textcolor{comment}{//~FASTQ}
2795                         \}
2796                     \}
2797                 \}\textcolor{comment}{//~for all reads}
2798             \}\textcolor{comment}{//~if (pairedin\_gv || pairedout\_gv)}
2799 
2800             \textcolor{comment}{/* output reads single */}
2801             \textcolor{keywordflow}{else}
2802             \{
2803                 \textcolor{comment}{/* loop through every read, output non-accepted reads */}
2804                 \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} i = 1; i < (int)strs; i+=2 )
2805                 \{
2806                     \textcolor{keywordtype}{char}* thisread = reads[i-1]+1;
2807 
2808                     \textcolor{keywordtype}{int} read1 = (i-1)>>1;
2809     
2810                     \textcolor{comment}{/* the read was not accepted */}
2811                     \textcolor{keywordflow}{if} ( read\_hits[read1] )
2812                     \{
2813 
2814                         \textcolor{comment}{/* accepted reads file output */}
2815                         \textcolor{keywordflow}{if} ( otherreads.is\_open() )
2816                         \{
2817                             otherreads << filesig;
2818 
2819                             \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2820                             \{
2821                                 \textcolor{keywordflow}{while} ( *thisread != \textcolor{charliteral}{'>'} && *thisread != \textcolor{charliteral}{'\(\backslash\)0'} )
2822                                     otherreads << (char)*thisread++;
2823                             \}\textcolor{comment}{//~FASTA}
2824                             \textcolor{keywordflow}{else}
2825                             \{
2826                                 \textcolor{keywordflow}{while} ( n\_count < 4 )
2827                                 \{
2828                                     otherreads << (char)*thisread;
2829                                     \textcolor{keywordflow}{if} ( *thisread == \textcolor{charliteral}{'\(\backslash\)0'} || *thisread++ == \textcolor{charliteral}{'\(\backslash\)n'} ) 
2830                                         n\_count++;  
2831                                 \}
2832                                 n\_count = 0;
2833                             \}\textcolor{comment}{//~FASTQ}
2834                         \}
2835                     \}
2836                 \}\textcolor{comment}{//~for all reads}
2837             \}\textcolor{comment}{//if (pairedin\_gv || pairedout\_gv)}
2838 
2839             \textcolor{keywordflow}{if} ( otherreads.is\_open() )
2840                 otherreads.close();
2841         \}\textcolor{comment}{//~if ( ptr\_filetype\_or != NULL )}
2842 
2843         TIME(f);
2844 
2845         eprintf(\textcolor{stringliteral}{"    Time to output reads to file                     [%.2f sec]\(\backslash\)n\(\backslash\)n"}, (f-s) );
2846 
2847     \textcolor{comment}{/* free the bridgeread */}
2848     \textcolor{keywordflow}{if} ( bridgeread != NULL )
2849     \{
2850             \textcolor{keyword}{delete} [] bridgeread;
2851             bridgeread = NULL;
2852     \}
2853 
2854     \textcolor{comment}{/* record the start of the bridge read if it exists */}
2855         \textcolor{keywordflow}{if} ( file\_s < file\_sections - 1 )
2856     \{
2857             \textcolor{keywordflow}{if} ( num\_newlines\_bottom > 0 || goback || offset\_bottom )
2858             \{
2859                 bridgeread = \textcolor{keyword}{new} \textcolor{keywordtype}{char}[(READLEN*2)];
2860 
2861                 \textcolor{keywordflow}{if} ( bridgeread == NULL )
2862                 \{
2863                     fprintf(stderr, \textcolor{stringliteral}{"  ERROR: could not allocate memory for the bridged read\(\backslash\)n"});
2864                     exit(EXIT\_FAILURE);
2865                 \}
2866 
2867                 \textcolor{comment}{/* compute the first half of the bridgeread */}
2868             \textcolor{keywordtype}{char} *start = &raw[partial\_file\_size]-reads\_offset\_e;
2869                 \textcolor{keywordtype}{char} *end = &raw[partial\_file\_size];
2870 
2871                 bridgeptr = bridgeread;
2872             
2873                 \textcolor{keywordflow}{while} ( start != end )
2874                 \{   
2875                     *bridgeptr++ = *start++;
2876                 \}
2877             \}
2878 
2879     \}\textcolor{comment}{// (s < file\_sections - 1)}
2880 
2881     \textcolor{comment}{/* compute the new number of newlines at top of next file section */}
2882     \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'@'} )
2883         \{
2884                 \textcolor{keywordflow}{if} ( num\_newlines\_bottom > 0 || goback )
2885                     num\_newlines\_top = 4-num\_newlines\_bottom;
2886                 \textcolor{keywordflow}{else}
2887                     num\_newlines\_top = 0;
2888 
2889                 \textcolor{comment}{/* the possibly split read is the second read of the paired reads */}
2890                 \textcolor{keywordflow}{if} ( offset\_bottom )    
2891                 \{
2892                     \textcolor{comment}{/* |-------------| |------------|}
2893 \textcolor{comment}{               *}
2894 \textcolor{comment}{               *                ^ the file is split at a point where the two paired-reads are}
2895 \textcolor{comment}{               *                  exactly divided}
2896 \textcolor{comment}{               **/}
2897                     \textcolor{keywordflow}{if} ( num\_newlines\_bottom == 0 && !goback )
2898                         offset\_top = \textcolor{keyword}{true};
2899 
2900                     \textcolor{comment}{/* |-------------| |------------|}
2901 \textcolor{comment}{               *}
2902 \textcolor{comment}{               *                    ^ the file is split at a point where the second paired read is}
2903 \textcolor{comment}{               *                      divided (the first paired read is in the current file section)}
2904 \textcolor{comment}{               **/}
2905                     \textcolor{keywordflow}{else}
2906                         offset\_top = \textcolor{keyword}{false};
2907 
2908                     offset\_bottom = \textcolor{keyword}{false};
2909                 \}
2910                 \textcolor{comment}{/* the possibly split read is the first of the paired reads  */}
2911                 \textcolor{keywordflow}{else}
2912                 \{
2913                     \textcolor{comment}{/* |-------------| |------------|}
2914 \textcolor{comment}{               *}
2915 \textcolor{comment}{               *                               ^ the file is split at a point where the two paired-reads}
2916 \textcolor{comment}{               *                                 fit exactly into the partial file section}
2917 \textcolor{comment}{               **/}
2918                     \textcolor{keywordflow}{if} ( num\_newlines\_bottom == 0 && !goback )
2919                         offset\_top = \textcolor{keyword}{false};
2920 
2921                     \textcolor{comment}{/* |-------------| |------------|}
2922 \textcolor{comment}{               *}
2923 \textcolor{comment}{               *           ^ the file is split at a point where the first paired read}
2924 \textcolor{comment}{               *             is divided (the second paired read starts in the next partial file section)}
2925 \textcolor{comment}{               **/}
2926                     \textcolor{keywordflow}{else}
2927                         offset\_top = \textcolor{keyword}{true};
2928                 \}
2929         \}
2930 
2931         \textcolor{keywordflow}{if} ( filesig == \textcolor{charliteral}{'>'} )
2932         \{
2933             \textcolor{keywordflow}{if} ( offset\_bottom )
2934                 offset\_top = \textcolor{keyword}{false};
2935             \textcolor{keywordflow}{else}    
2936                 offset\_top = \textcolor{keyword}{true};
2937 
2938             offset\_bottom = \textcolor{keyword}{false};
2939         \}
2940 
2941         \textcolor{comment}{/* free the mmap'd file section */}
2942     \textcolor{keywordflow}{if} ( munmap(raw, partial\_file\_size ) == -1 )
2943     \{
2944       fprintf(stderr,\textcolor{stringliteral}{"  ERROR: Could not munmap file!\(\backslash\)n"});
2945       exit(EXIT\_FAILURE);
2946     \}
2947 
2948     offset+=\hyperlink{main_8cpp_ade15ad3c0e7a4fb18c3f557d575acf9a}{map\_size\_gv};
2949 
2950     \textcolor{comment}{/* last section of the full file, count strings until EOF is reached */}
2951     \textcolor{keywordflow}{if} ( ++file\_s == file\_sections - 1 ) partial\_file\_size = last\_part\_size;
2952 
2953         \textcolor{keyword}{delete} [] reads;
2954         reads = NULL;
2955 
2956   \}\textcolor{comment}{//~while ( file\_s < file\_sections )}
2957 
2958     free(mat);
2959     mat = NULL;
2960 
2961             
2962     \textcolor{comment}{/* free memory of accepted strings */}
2963     \textcolor{keywordflow}{if} ( acceptedstrings != NULL )
2964     \{
2965         \textcolor{keyword}{delete} [] acceptedstrings;
2966         acceptedstrings = NULL;
2967     \}
2968 
2969     \textcolor{keywordflow}{if} ( acceptedstrings\_sam != NULL )  
2970     \{
2971         \textcolor{keyword}{delete} [] acceptedstrings\_sam;
2972         acceptedstrings\_sam = NULL;
2973     \}
2974 
2975     \textcolor{keywordflow}{if} ( acceptedstrings\_blast != NULL )
2976     \{
2977         \textcolor{keyword}{delete} [] acceptedstrings\_blast;
2978         acceptedstrings\_blast = NULL;
2979     \}
2980 
2981 
2982 
2983     return ;
2984 
2985 \}\textcolor{comment}{//~paralleltraversal()}
\end{DoxyCode}
\hypertarget{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!traversetrie\-\_\-align@{traversetrie\-\_\-align}}
\index{traversetrie\-\_\-align@{traversetrie\-\_\-align}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{traversetrie\-\_\-align}]{\setlength{\rightskip}{0pt plus 5cm}void traversetrie\-\_\-align (
\begin{DoxyParamCaption}
\item[{Node\-Element $\ast$}]{trie\-\_\-t, }
\item[{unsigned int}]{lev\-\_\-t, }
\item[{unsigned char}]{depth, }
\item[{M\-Y\-B\-I\-T\-S\-E\-T $\ast$}]{win\-\_\-k1\-\_\-ptr, }
\item[{M\-Y\-B\-I\-T\-S\-E\-T $\ast$}]{win\-\_\-k1\-\_\-full, }
\item[{bool \&}]{accept\-\_\-zero\-\_\-kmer, }
\item[{vector$<$ id\-\_\-win $>$ \&}]{id\-\_\-hits, }
\item[{int}]{readn, }
\item[{int}]{win\-\_\-num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}}\label{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}

\begin{DoxyCode}
159 \{
160     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{short} \textcolor{keywordtype}{int} lev\_t\_trie\_pivot = lev\_t;
161     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} value = 0;
162                     
163     \textcolor{comment}{/* traverse through the node elements in a trie node */}
164     \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} node\_element = 0; node\_element < 4; node\_element++ )
165     \{
166         value = trie\_t->flag;
167 
168         \textcolor{comment}{/* this node element is empty, go to next node element in trie node */}
169     \textcolor{keywordflow}{if} ( value == 0 ) 
170     \{    
171             lev\_t = lev\_t\_trie\_pivot;
172             trie\_t++;
173     \}
174 
175       \textcolor{comment}{/* this node element points to a trie node or a bucket, continue traversing */}
176       \textcolor{keywordflow}{else}
177       \{
178             \textcolor{keywordflow}{if} ( depth < \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-2 )
179             \{
180                 \textcolor{comment}{/* send bv to LEV(1) */}
181                 lev\_t = \hyperlink{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{table}[0][(int)*(win\_k1\_ptr + (depth<<2) + node\_element)][(\textcolor{keywordtype}{int})(lev\_t)];
182             \}
183         \textcolor{keywordflow}{else}
184         \{
185                 lev\_t = \hyperlink{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{table}[3-\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}+depth][(int)(*(win\_k1\_full+node\_element) & 
      ((2<<(\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-depth))-1))][(int)(lev\_t)];
186             \}
187 
188 
189             \textcolor{comment}{/* LEV(1) is in a null state, go to next node element */}
190             \textcolor{keywordflow}{if} ( lev\_t == 14 ) 
191             \{ 
192                 lev\_t = lev\_t\_trie\_pivot;
193                 trie\_t++;
194             \}
195             \textcolor{comment}{/* LEV(1) is not in a null state, continue parallel traversal */}
196             \textcolor{keywordflow}{else}
197             \{
198                 \textcolor{comment}{/* (1) the node element holds a pointer to another trie node */}
199                 \textcolor{keywordflow}{if} ( value == 1 )
200                 \{ 
201                     \hyperlink{paralleltraversal_8cpp_a9dca68a7f6da675cdf8b96caebd4bf59}{traversetrie\_align} ( trie\_t->whichnode.trie,
202                                             lev\_t,
203                                             ++depth,
204                                             win\_k1\_ptr,
205                                             win\_k1\_full,
206                                             accept\_zero\_kmer,
207                                             id\_hits,
208                                             readn,
209                                             win\_num
210                                             );
211     
212                     \textcolor{comment}{/* go to next window on the read (0-error match found) */}
213                     \textcolor{keywordflow}{if} ( accept\_zero\_kmer ) return ;    
214 
215                     --depth;
216 
217                     \textcolor{comment}{/* go to the next trie node element */}
218                     lev\_t = lev\_t\_trie\_pivot;
219                     trie\_t++;
220                 \}\textcolor{comment}{//~ if (child node a trie node)}
221 
222         \textcolor{comment}{/* (2) the node element points to a bucket */}
223         \textcolor{keywordflow}{else} 
224         \{
225             \textcolor{comment}{/* this pivot remembers the target levenshtein state of the terminal trie node, from }
226 \textcolor{comment}{                which exists a bucket; every element in the bucket takes this lev\_t state as an }
227 \textcolor{comment}{                initial input state */}
228             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} lev\_t\_bucket\_pivot = lev\_t;
229                   
230                     \textcolor{comment}{/* number of characters per entry */}
231                     \textcolor{keywordtype}{int} s = \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-depth;
232 
233                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* start\_bucket = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)trie\_t->whichnode.bucket;     
234                     if ( start\_bucket == NULL )
235                     \{
236                         fprintf(stderr, \textcolor{stringliteral}{"  ERROR: pointer start\_bucket == NULL (paralleltraversal.cpp)\(\backslash\)n"});
237                         exit(EXIT\_FAILURE);
238                     \}   
239                     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* end\_bucket = start\_bucket + trie\_t->size;
240                     \textcolor{keywordflow}{if} ( end\_bucket == NULL )
241                     \{
242                         fprintf(stderr, \textcolor{stringliteral}{"  ERROR: pointer end\_bucket == NULL (paralleltraversal.cpp)\(\backslash\)n"});
243                         exit(EXIT\_FAILURE);
244                     \}   
245 
246             \textcolor{comment}{/* traverse the bucket */}
247             \textcolor{keywordflow}{while} ( start\_bucket != end\_bucket )
248             \{
249                         \textcolor{keywordtype}{int} depth\_b = depth;
250                 lev\_t = lev\_t\_bucket\_pivot;
251                         \textcolor{keywordtype}{bool} local\_accept\_kmer = \textcolor{keyword}{false};
252                         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} entry\_str = *((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket);
253                 
254                         \textcolor{comment}{/* for each nt in the string */}
255                         \textcolor{keywordflow}{for} ( \textcolor{keywordtype}{int} j = 0; j < s; j++ )
256                         \{
257                             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nt = entry\_str&3;
258 
259                             depth\_b++;
260 
261                     \textcolor{comment}{/* get bitvector for letter */}
262                             \textcolor{keywordflow}{if} ( depth\_b < \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-2 )
263                             \{
264                         \textcolor{comment}{/* send bv to LEV(\_k) */}
265                                 lev\_t = \hyperlink{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{table}[0][(int)*(win\_k1\_ptr + (depth\_b<<2) + nt)][(\textcolor{keywordtype}{int})(lev\_t)]
      ;
266                             \}
267                             \textcolor{keywordflow}{else}
268                             \{
269                                 lev\_t = \hyperlink{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{table}[3-\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}+depth\_b][(int)(*(
      win\_k1\_full + nt) & ((2<<(\hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-depth\_b))-1) )][(int)(lev\_t)];
270                             \}
271 
272                     \textcolor{comment}{/* if the target lev\_t state is a failure state, go to the next bucket element (tail) 
      */}            
273                         \textcolor{keywordflow}{if} ( lev\_t == 14 ) 
274                             \{ 
275                                     \textcolor{keywordflow}{break};
276                             \}
277 
278                             \textcolor{comment}{/* approaching end of tail */}
279                             \textcolor{keywordflow}{if} ( depth\_b >= \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-2 )
280                             \{
281                                 \textcolor{comment}{/* 1-error match */}
282                                 \textcolor{keywordflow}{if} ( lev\_t >= 8 )
283                                 \{
284                                     local\_accept\_kmer = \textcolor{keyword}{true};
285                                 \}
286                                 \textcolor{comment}{/* 0-error match */}
287                                 \textcolor{keywordflow}{if} ( depth\_b == \hyperlink{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{partialwin\_gv}-1 )
288                                 \{
289                                     \textcolor{keywordflow}{if} ( lev\_t == 9 )
290                                     \{
291                                         accept\_zero\_kmer = \textcolor{keyword}{true};
292                                         \textcolor{comment}{/* turn off heuristic to stop search after finding 0-error match */}
293                                         \textcolor{keywordflow}{if} ( \hyperlink{main_8cpp_a20b60a4bf8932abc78c6eb7a3eb069c5}{full\_search\_gv} )
294                                             accept\_zero\_kmer = \textcolor{keyword}{false};
295                                     \}
296                                 \}
297                             \}\textcolor{comment}{//~last 3 characters in entry}
298 
299                       \textcolor{keywordflow}{if} ( local\_accept\_kmer )
300                       \{
301                                 id\_win entry = \{0,0\};
302                                 entry.id = *((\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int}*)start\_bucket + 1);
303                                 entry.win = win\_num;
304 
305                                 \textcolor{comment}{/* empty id\_hits array, add 0-error id and exit */}
306                                 \textcolor{keywordflow}{if} ( accept\_zero\_kmer )
307                                 \{
308                                     id\_hits.clear();
309                                     id\_hits.push\_back(entry);
310 
311                                     \textcolor{keywordflow}{return};
312                                 \}
313 
314                                 \textcolor{comment}{/* exact match not found, do not include duplicates of 1-error match */}
315                                 \textcolor{keywordflow}{if} ( !id\_hits.empty() )
316                                     \textcolor{keywordflow}{if} ( id\_hits.back().id == entry.id )
317                                         \textcolor{keywordflow}{break};
318 
319                                 id\_hits.push\_back(entry);
320 
321                             \}
322 
323                             entry\_str>>=2;
324                         \}\textcolor{comment}{//~for each 2 bits}
325 
326                         \textcolor{comment}{/* next entry */}
327                         start\_bucket+=\hyperlink{paralleltraversal_8cpp_a852c3b510e1152c85991da7f3409b4d3}{ENTRYSIZE};
328                     \}\textcolor{comment}{//~for each entry}
329 
330                     lev\_t = lev\_t\_trie\_pivot;
331                 trie\_t++;
332 
333             \}\textcolor{comment}{//~else the node element points to a bucket}
334         \}\textcolor{comment}{//~else LEV(1) is not in a null state, continue parallel traversal}
335         \}\textcolor{comment}{//~else this node element points to a trie node or a bucket, continue traversing}
336     \}\textcolor{comment}{//~for all trie nodes}
337 
338     return ;
339 
340 \}\textcolor{comment}{//~traversetrie\_align()}
\end{DoxyCode}


\subsection{Variable Documentation}
\hypertarget{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!background\-\_\-freq\-\_\-gv@{background\-\_\-freq\-\_\-gv}}
\index{background\-\_\-freq\-\_\-gv@{background\-\_\-freq\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{background\-\_\-freq\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}double background\-\_\-freq\-\_\-gv\mbox{[}4\mbox{]} = \{0\}}}\label{paralleltraversal_8cpp_a49db5b23f4d2dd0b36cb39fe404b30e1}
\hypertarget{paralleltraversal_8cpp_adf8e093429055846312e4c3c3d564c1f}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!complement@{complement}}
\index{complement@{complement}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{complement}]{\setlength{\rightskip}{0pt plus 5cm}char complement\mbox{[}4\mbox{]} = \{3,2,1,0\}}}\label{paralleltraversal_8cpp_adf8e093429055846312e4c3c3d564c1f}
\hypertarget{paralleltraversal_8cpp_a8447db76b0717fd47ccc36b5ddb79bef}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!entropy\-\_\-\-H\-\_\-gv@{entropy\-\_\-\-H\-\_\-gv}}
\index{entropy\-\_\-\-H\-\_\-gv@{entropy\-\_\-\-H\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{entropy\-\_\-\-H\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}double entropy\-\_\-\-H\-\_\-gv = 0.\-0}}\label{paralleltraversal_8cpp_a8447db76b0717fd47ccc36b5ddb79bef}
\hypertarget{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!expect\-\_\-\-L\-\_\-gv@{expect\-\_\-\-L\-\_\-gv}}
\index{expect\-\_\-\-L\-\_\-gv@{expect\-\_\-\-L\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{expect\-\_\-\-L\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}long long expect\-\_\-\-L\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a2c40619068bc285d8f2bccddd2baca3a}
\hypertarget{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!full\-\_\-read\-\_\-gv@{full\-\_\-read\-\_\-gv}}
\index{full\-\_\-read\-\_\-gv@{full\-\_\-read\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{full\-\_\-read\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}long long full\-\_\-read\-\_\-gv = 0}}\label{paralleltraversal_8cpp_ac245c75a34b4b055137507a14636c327}
\hypertarget{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!full\-\_\-ref\-\_\-gv@{full\-\_\-ref\-\_\-gv}}
\index{full\-\_\-ref\-\_\-gv@{full\-\_\-ref\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{full\-\_\-ref\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}long long full\-\_\-ref\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a29ba39ec48930479b8b1b5090d8239bc}
\hypertarget{paralleltraversal_8cpp_a6ef7f11ffe917af62a9e613446b4957a}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!id\-\_\-it@{id\-\_\-it}}
\index{id\-\_\-it@{id\-\_\-it}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{id\-\_\-it}]{\setlength{\rightskip}{0pt plus 5cm}set$<$unsigned int$>$\-::iterator id\-\_\-it}}\label{paralleltraversal_8cpp_a6ef7f11ffe917af62a9e613446b4957a}
\hypertarget{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!K\-\_\-gv@{K\-\_\-gv}}
\index{K\-\_\-gv@{K\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{K\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}double K\-\_\-gv = -\/1.\-0}}\label{paralleltraversal_8cpp_aa32740bcde4577cd7af494e1a5b50f47}
\hypertarget{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!lambda\-\_\-gv@{lambda\-\_\-gv}}
\index{lambda\-\_\-gv@{lambda\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{lambda\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}double lambda\-\_\-gv = -\/1.\-0}}\label{paralleltraversal_8cpp_a899f21fc37d2a96c3c7fa6e697af71c9}
\hypertarget{paralleltraversal_8cpp_a2582d8e7e72b78283ba60394bbe9adb4}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!leaf@{leaf}}
\index{leaf@{leaf}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{leaf}]{\setlength{\rightskip}{0pt plus 5cm}int leaf = 0}}\label{paralleltraversal_8cpp_a2582d8e7e72b78283ba60394bbe9adb4}
\hypertarget{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!lnwin\-\_\-gv@{lnwin\-\_\-gv}}
\index{lnwin\-\_\-gv@{lnwin\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{lnwin\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int lnwin\-\_\-gv = -\/1}}\label{paralleltraversal_8cpp_ae5afe6be7bd736d06d763ff7822a824b}
\hypertarget{paralleltraversal_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!mask32@{mask32}}
\index{mask32@{mask32}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{mask32}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int mask32 = 0}}\label{paralleltraversal_8cpp_a8d245ae3894bde05a4e8270ae47ae4fb}
\hypertarget{paralleltraversal_8cpp_a322857d371001fcdc993be8b69d49d01}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!minimal\-\_\-score\-\_\-gv@{minimal\-\_\-score\-\_\-gv}}
\index{minimal\-\_\-score\-\_\-gv@{minimal\-\_\-score\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{minimal\-\_\-score\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int minimal\-\_\-score\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a322857d371001fcdc993be8b69d49d01}
\hypertarget{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!number\-\_\-total\-\_\-read\-\_\-gv@{number\-\_\-total\-\_\-read\-\_\-gv}}
\index{number\-\_\-total\-\_\-read\-\_\-gv@{number\-\_\-total\-\_\-read\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{number\-\_\-total\-\_\-read\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}long long number\-\_\-total\-\_\-read\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a339f4bb7ee9d9ba4b9a6a5531570a34f}
\hypertarget{paralleltraversal_8cpp_ab9275c2d178b44582254272d1bc88b34}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!numbvs\-\_\-gv@{numbvs\-\_\-gv}}
\index{numbvs\-\_\-gv@{numbvs\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{numbvs\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int numbvs\-\_\-gv = 0}}\label{paralleltraversal_8cpp_ab9275c2d178b44582254272d1bc88b34}
\hypertarget{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!numseq\-\_\-gv@{numseq\-\_\-gv}}
\index{numseq\-\_\-gv@{numseq\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{numseq\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}size\-\_\-t numseq\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a5910e33ee47f30c554367712abd9fec6}
\hypertarget{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!partialwin\-\_\-gv@{partialwin\-\_\-gv}}
\index{partialwin\-\_\-gv@{partialwin\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{partialwin\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int partialwin\-\_\-gv = -\/1}}\label{paralleltraversal_8cpp_a8d8e3eca9b6dafc49f6eede2a85138ef}
\hypertarget{paralleltraversal_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!pread\-\_\-gv@{pread\-\_\-gv}}
\index{pread\-\_\-gv@{pread\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{pread\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int pread\-\_\-gv = -\/1}}\label{paralleltraversal_8cpp_a723d1495d7b7dcb58277d4da9cbe29cc}
\hypertarget{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!table@{table}}
\index{table@{table}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{table}]{\setlength{\rightskip}{0pt plus 5cm}unsigned int table\mbox{[}4\mbox{]}\mbox{[}16\mbox{]}\mbox{[}14\mbox{]}}}\label{paralleltraversal_8cpp_a4632424eb2dea529266e95ec7808ceed}
\hypertarget{paralleltraversal_8cpp_ae3449226a5476670d1618cda4c098202}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!to\-\_\-char@{to\-\_\-char}}
\index{to\-\_\-char@{to\-\_\-char}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{to\-\_\-char}]{\setlength{\rightskip}{0pt plus 5cm}char to\-\_\-char\mbox{[}4\mbox{]} = \{'A','C','G','T'\}}}\label{paralleltraversal_8cpp_ae3449226a5476670d1618cda4c098202}
\hypertarget{paralleltraversal_8cpp_a192f0b0d3603008657d8cee829933644}{\index{paralleltraversal.\-cpp@{paralleltraversal.\-cpp}!total\-\_\-read\-\_\-gv@{total\-\_\-read\-\_\-gv}}
\index{total\-\_\-read\-\_\-gv@{total\-\_\-read\-\_\-gv}!paralleltraversal.cpp@{paralleltraversal.\-cpp}}
\subsubsection[{total\-\_\-read\-\_\-gv}]{\setlength{\rightskip}{0pt plus 5cm}int total\-\_\-read\-\_\-gv = 0}}\label{paralleltraversal_8cpp_a192f0b0d3603008657d8cee829933644}
